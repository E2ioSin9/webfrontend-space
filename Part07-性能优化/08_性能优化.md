
1. 虚拟 dom
2. diff 算法




# react性能优化

## 获取数据


## 渲染优化
### 组件的props
- `组件的props如果传的是引用类型，尽量保证是同一个JS对象`

```javascript
//第一种写法
<Foo style={{ color:"red" }}
```
每一次渲染都会被认为是一个style这个prop发生了变化，因为每一次都会产生一个对象给style。
```
//第二种写法
const fooStyle = { color: "red" }; //确保这个初始化只执行一次，不要放在render中，可以放在构造函数中
<Foo style={fooStyle} />
```
保证prop指向同一个JS对象
### render里面绑定事件
- `render里面绑定事件时，尽量减少bind函数和箭头函数`，尽量减少传递参数的数量。
```javascript
//第一种
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }
<button onClick={this.handleClick()}>btn1</button>
//第二种
<button onClick={this.handleClick.bind(this)}>btn2</button>
//第三种
<button onClick={()=>this.handleClick()}>btn3</button>
```
三种写法，第一种性能最优，构造函数每一次渲染的时只会执行一遍，不过现在一般使用箭头函数，就不用在constructor中绑定this了；
第二种方法，在每次render()时执行bind函数，都会生成一个匿名函数；
第三种方法，每一次render()，都会生成一个新的箭头函数。
### `定制shouldComponentUpdate函数`
当title值发生改变的时候，我们才去render，可以这样写：
```javascript
shouldComponentUpdate(nextProps,nextState){
    if(nextProps.title === this.props.title){
        return false;
    }
    return true;
}
```
在最新的react中，react给我们提供了React.PureComponent，官方也在早期提供了名为react-addons-pure-render-mixin插件来重新实现shouldComponentUpdate生命周期方法。这样就不用写should这一套了。
需要注意的是：PureComponent 内进行的仅仅是`浅比较对象（shallowCompare）`。如果对象包含了复杂的数据结构，深层次的差异可能会产生误判。


[React组件性能调优](http://react-china.org/t/react/11562)