
目录

[TOC]



# 渲染优化
## 渲染列表使用 key

## 自定义事件、DOM 事件及时销毁

## 合理使用异步加载组件
通过 import() 、React.lazy 和 Suspense 共同实现 React 的懒加载。


## render 里面绑定事件时，尽量减少 bind 函数和箭头函数
  ```javascript
  //第一种
    constructor(props) {
      super(props);
      this.handleClick = this.handleClick.bind(this);
    }
  <button onClick={this.handleClick()}>btn1</button>
  //第二种
  <button onClick={this.handleClick.bind(this)}>btn2</button>
  //第三种
  <button onClick={()=>this.handleClick()}>btn3</button>
  ```
  三种写法，第一种性能最优，构造函数每一次渲染的时只会执行一遍，现在一般使用箭头函数，就不用在 constructor 中绑定 this了；
  第二种，在每次 render() 时执行 bind 函数，都会生成一个匿名函数；
  第三种，每一次 render()，都会生成一个新的箭头函数。



## 合理使用 SCU、PureComponent、memo
**React 默认：父组件有更新，子组件则无条件更新！！！** 

无条件的意思是：**父组件只要重新 render，子组件都会执行，不管子组件的 props 是否变化**。这是非常没有必要的。


ShouldComponentUpdate 配合不可变值，定制返回 false，“阻止”重新渲染。
isEqual 深度比较 需要一次性递归到底，也是非常消耗性能的。所以一般并不建议 这样 在 SCU 中使用深度比较（慎用）


那么，React 有提供做 **浅比较（只比较第一层属性）** 的方案吗 ？？？
- React.PureComponent，class 组件中。
=> 相比于 React.Component，在 SCU 中实现了对 props 和 state 的浅比较
=> 也需要配合不可变值来使用
- React.memo，在函数组件中，实现了对 props 的浅比较。




## 保证数据的不可变性
合理使用 immutable.js，为什么要引入？

## 不在 render 中处理数据

## 不必要的标签，使用 React.Fragments


# webpack 层面的优化




