目录

[TOC]

生命周期函数：描述一个组件或程序从创建到销毁的过程，在这个过程中，某一时刻会调用的钩子函数

# v16.3 之前老的生命周期
[old-demo](https://codesandbox.io/s/react-old-lifecycles-0y05e)


洋葱模型：
- componentWillMount -> componentDidMount
- componentWillUpdate-> componentDidUpdate

  ![onion](https://user-images.githubusercontent.com/22387652/81921623-7a5edd00-960d-11ea-8d8e-7483f941fe14.png)


# v16.4 之后新的生命周期
![new](https://user-images.githubusercontent.com/22387652/79878598-30287880-8420-11ea-979e-91c0827db353.png)

## Mounting（挂载阶段）
挂载：当组件实例第一次被创建并插入 真实 DOM 中，也就是，第一次被渲染到页面的过程。
- `constructor()`：初始化 state。相当于 Vue 的 mounted。

- `static getDerivedStateFromProps(props, state)`：第一次挂载之前

- `render()`：第一次挂载的过程
返回以下类型：React 元素、数组或 fragments 等

- `componentDidMount()`：第一次挂载之后
DOM 元素挂载完成，可以获取到。相当于 Vue 的 mounted。
  + 初始化 DOM 节点（比如 大小或位置）、操作真实的 DOM
  + 发送异步 AJAX 请求，获取数据

注意：
1. constructor() 和 componentDidMount() 在组件的生命周期`仅执行一次`
2. UNSAFE_componentWillMount()：第一次挂载之前
在这获取 DOM 元素是 undefined。相当于 Vue 的 beforeMount。


## Updation（更新流程）

当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

- `static getDerivedStateFromProps(props, state)`：在每次渲染前触发。

- `shouldComponentUpdate(nextProps, nextState)`：当 props 或 state 发生变化时被调用。默认返回 true，返回 false，不执行执行后面的钩子函数，会“阻止”重新渲染。
  + this.state、this.props：页面渲染用的原来的值
  + nextProps、nextState：最新修改的，即将用它来渲染页面的值
  

- `render()`：将新虚拟 DOM 与原来的进行比对（diff），然后修改真实DOM，重新渲染

- `getSnapshotBeforeUpdate(prevProps, prevState)`：render 之后、更新 DOM 和 refs 之前调用。

- `componentDidUpdate(prevProps, prevState, snapshot)`：重新渲染之后
  + this.state、this.props：最新修改的值
  + prevProps、prevState：页面渲染用的之前的值
  + snapshot：getSnapshotBeforeUpdate() 的返回值作为第三个参数

  => 通过比较 props，做一些操作：比如功能开关、发送请求。它必须被包裹在一个条件语句里，否则会导致死循环。


注意：
- 三种情况 props 会改变：
  + 父组件、或者 redux，通过 props 传递的数据发生改变
  + 路由切换引起的 props 上的 history/match/location 变化会触发
  
- 避免使用它们：UNSAFE_componentWillReceiveProps(nextProps, nextState)、UNSAFE_componentWillUpdate(nextProps, nextState)


## Unmounting（卸载流程）
当组件被卸载、销毁之前调用：

- `componentWillUnmount()`：一般用于做善后工作，比如，重置数据、清除 timer、取消订阅。相当于 Vue 的 beforeUpdate 

## 错误处理阶段
- `componentDidCatch(error, info)`：后代组件抛出错误后被调用。info-带有 componentStack key 的对象


# 总结
React 团队目前致力于打造异步渲染的机制，以进一步提高 React 的渲染效率。

将会在 V17 版本中，使用新的异步渲染机制，即可被打断的生命周期。发生在 render() 函数执行之前的虚拟 DOM 阶段，也就是现有三个 API 被舍弃的原因（可能被重复调用导致一系列性能问题）。 想了解具体细节需要去了解 fiber reconcliler 对 stack reconcliler 的性能改进。

## 新生命周期中的改变
新的生命周期增加了 static getDerivedStateFromProps(props, state) 和 
getSnapshotBeforeUpdate(prevProps, prevState)，废弃了 componentWillMount、componentWillUpdate、componentWillReceiveProps。


### static getDerivedStateFromProps(props, state)
在初始挂载及后续更新时都会被调用。它应`返回一个对象来更新 state`，如果返回 null 则不更新任何内容。

注意：
- 不管是 `props 或 state` 发生变化，在每次渲染前都会被触发。这与 UNSAFE_componentWillReceiveProps 形成对比（仅在 props 发生改变后触发，而不是内部调用 setState 时）
- static 表明是一个`静态方法`，而组件实例无法继承静态方法，所以该钩子函数内部`不能通过使用 this 获取组件实例的属性/方法`。

作用： 将父组件传递过来的 props 映射 到子组件的 state 上面，映射就相当于拷贝了一份父组件传过来的 props ，作为子组件自己的状态。注意：子组件通过 setState 更新自身状态时，不会改变父组件的 props

[online-demo](https://codesandbox.io/s/react-getderivedstatefromprops-mf95q)


### getSnapshotBeforeUpdate(prevProps, prevState)
应返回 snapshot 的值（或 null），作为 componentDidUpdate 的第三个参数。
=> 常用于在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）

[online-demo](https://codesandbox.io/s/react-getsnapshotbeforeupdate-ij31n)


## 为什么去掉了那几个旧的生命周期？
### 可能被执行多次
被废弃的三个钩子函数都是在 render 之前调用，因为 Fiber 机制的出现，很可能因为高优先级的任务的出现而打断现有任务导致它们被执行多次。

### React 要约束使用者
1. componentWillMount
   - 它要实现的功能，完全可以使用 DidMount 和 Constructor 来完成。
   - 由于 React Fiber 对 Reconciliation 算法的改进，在调用初始渲染之前，此函数可能被调用多次。
   - SSR 服务端渲染时，可以调用 WillMount 订阅事件，而不能调用其对称方法 WillUnmount，可能引起一系列副作用，并引发服务器端内存泄漏。

2. componentWillReceiveProps
  常见的一个业务场景：根据 props 的变化去更新 state，需要判断前后两个 props 的不同
   - 破坏 state 的单一数据源，导致组件状态变得不可预测
   - 增加组件的重绘次数（一次更新可能会被调用多次）
```js
// 从外部跳转到 tab 列表时，根据传入的某个值，直接高亮显示 某个 tab
// 原有
componentWillReceiveProps(nextProps) {
  if (nextProps.tab !== this.props.tab) {
    this.setState({
      tab: nextProps.tab,
    });
    this.tabChange();
  }
}

// 新的
static getDerivedStateFromProps(nextprops, prevState) {
  if (nextprops.tab !== prevState.tab) {
    return {
      tab: nextprops.tab,
    };
  }
  return null;
}
componentDidUpdate() {
  this.tabChange();
}
```
新的生命周期优点：
- getDSFP 是一个 静态方法，里边不能用 this，是一个纯函数，限制了开发者不能写出副作用的代码
- 只能通过 prevState 比较，保证了 state 和 props 的简单关系
- 将 状态变化（setState）和 昂贵操作（tabChange）分离开来，便于 render 和 commit 操作优化

3. componentWillUpdate
与 类似，一次更新可能会被调用多次。而 DidUpdate 在一次更新中只会被调用一次。


# 常见面试题
## 说一下 React 组件的生命周期，都有哪些改变（重要！！！）
=> 有哪些改变？
=> 为什么去掉了那几个旧的生命周期？
=> 原来的 componentWillReceiveProps，用什么来代替？
=> 哪几个你用的比较多，在什么情况下用这个？
=> ajax 应该放在哪个生命周期上？






