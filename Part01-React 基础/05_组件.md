目录

[TOC]

按照组件/模块管理的方式来构建程序，也就是把一个程序划分为一个个的组件来单独处理。

# 函数组件
1. 基础语法
- 接收 “props”（代表属性）对象（不传递是一个空对象）
  + children：`是一个不透明的数据结构`，可能是任何类型
    + 组件没有子元素（单闭合）时，是 undefined
    + 组件有子元素（双闭合）时，可能是一个值(字符串、对象)或一个数组
- 并返回一个 React 元素
- 本质上就是 JavaScript 函数
```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
ReactDOM.render(<div>
    <Welcome />
    <Welcome name='CHEN'>
        <span>1</span>
    </Welcome>
</div>, root);
```
注意：
- 在 JS 文件中，凡是用到 JSX 结构的，都要引入 React，因为需要基于它的 createElement 把 JSX 进行解析渲染。
- `React.Children 对象`，提供了 map、forEach 等方法专门处理 this.props.children。 [对React children 的深入理解](https://www.jianshu.com/p/d1975493b5ea)


# class 组件
1. 基础语法
使用 ES6 的 class 来定义组件：
- 必须有一个 render() 的方法，返回一个 JSX 元素
- super() 相当于 ==React.Component.call(this)==
  function Component(props, context, updater) { ... }
  
```js
class Welcome extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```
注意：
- `super()` 与 `super(props)`的区别：传入 props 是，将传递的属性挂载到子类的实例上，在 constructor 中可以使用 this.props；不传，this.props 拿到的是 undefined。super() 仅仅影响的是在 constructor 中获取 this.props；
- 执行完成 constructor，react 已经帮我们把传递的属性接收，并且挂载到实例上，其它生命周期函数中都可以使用 this.props

# 应用
1. 函数组件
函数组件是一个**纯函数**：输入 Props 和 返回 JSX。可以理解为`静态组件`。
[所谓静态组件，就是组件的内容是固定的，调取一次，就是将组件的内容插入到页面中，不需要与数据 model 进行交互。]

    适用于：**只是简单的 输入 Props 和 返回 JSX 而已，不需要动态交互的情况**，例如，获取数据，绑定HTML


2. class 组件，可以理解为`动态组件`。
    - 能够使用生命周期函数处理业务
    - 可以基于组件内部的状态（state）来动态更新渲染组件的情况

    适用于：`所有 需要和数据模型进行动态交互 的情况`。



# 渲染机制
基于 createElement 把 JSX 转换为一个对象，当 render 渲染这个对象时，遇到一个组件，type 不再是字符串标签名，而是一个函数或者类，不再是直接创建元素，而是先把方法执行：

- 函数组件：就把它当做`普通方法执行`（严格模式下，方法中的this是`undefined`），把函数返回的 JSX 元素（也是解析后的对象）进行渲染。

- class 组件：把`当前类 new 执行`，创建类的一个实例（当前本次调取的组件就是它的一个实例），执行 constructor 之后，会执行 this.render()，把 render 中返回的 JSX 拿过来渲染。

```js
{
	type: Welcome,//=>组件Welcome
	props: {
		name: 'CHEN'
    children: 一个值或一个数组
  }
}
```

不管是哪种方式，函数执行时，都会把解析出来的`props属性对象作为实参传递给函数`。







# 面试高频题目
1. React 受控组件和非受控组件的区别 *
- 按是否使用 state，还是 props 来分：
  + 受控组件（Controlled）
又称为 stateless 组件。所有的组件依赖项都通过 props 传递到组件中，是一个 纯函数。使用 stateless 组件，能够在很大程度上提高组件本身的稳定性。
  + 非受控组件（Uncontrolled）
又称为 stateful 组件。加入 state 之后，由于 state 是在组件内部的影响因素，外界难以控制 state 的变化，也无法得知 state 的变化，组件的不可控因素会增加，熵值增高。 

- 按表单来区分：
  + 受控组件：将表单元素的值与状态关联起来，通过 onChange 修改表单元素，实时映射到状态，就是受控组件，这个和双向绑定相似.
  + 非受控组件：表单元素的值不受 state 控制，一般 使用 defaultValue、defaultChecked 设置默认值，没有 onChange 事件，可通过 ref 获取 DOM 元素拿表单元素的值
  =》必须操作 DOM 时，使用非受控组件，比如文件上传、富文本编辑器
  