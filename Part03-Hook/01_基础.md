目录

[TOC]

# 什么是 Hook？
> Hook 是 React 16.8 的新增特性。它可以让你在**不编写 class 的情况下使用 state 以及其他的 React 特性**。

那么，什么是 Hook?

> **Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。**


**Hook 解决了什么问题？引入的动机：**
1. Hook 使你在无需修改组件结构的情况下复用状态逻辑
解决 render props 和 高阶组件，需要 重新组织组件结构，以及嵌套地狱的问题

2. Hook 可以将组件中相互关联的代码组合在一起，而并非强制按照生命周期划分
比如，创建订阅(componentDidMount)及取消订阅（componentWillUnmount），可以在一个 Effect Hook 中完成，不需要将它们拆分到不同的生命周期函数里。

3. Hook 则拥抱了函数，在非 class 的情况下可以使用更多的 React 特性
函数组件是无状态组件，但 Hook 引入了使用 React state 的能力


# 内置的 Hook

## State Hook
useState 就是一个 state Hook，语法：
```js
const [state, setState] = useState(initialState);
```
- 唯一的参数是初始 state：initialState
  + **只有在第一次渲染时会被用到，后续渲染会被忽略**
  + 可以是对象、基本值，这点不同于 this.state
- 返回一对值：当前 state 以及更新 state 的函数（数组解构语法）
  + state：
    + 第一次渲染：返回的状态 state 与 initialState 值相同
    + 后续更新渲染：将始终返回 更新后最新的 state
  + setState：
    + 相当于 class 组件的 this.setState，但它不会把新 state 和旧 state 进行合并


```js
import React, { useState } from 'react';

function Example() {
  // 声明一个叫 “count” 的 state 变量。
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果，也可以使用 Object.assign()。
```js
const [option, setOption] = useState({ count: 0, name: "chen" });

<button
  onClick={() =>
    setOption(prevState => ({
      ...prevState,
      count: prevState.count + 1
    }))
  }
>
  Click +
</button>
```




## Effect Hook
useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。**数据获取、添加订阅、设置定时器以及手动更改 DOM**等， 都属于副作用。

>可以把 useEffect Hook 看做 class 组件中 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。

语法：
> useEffect(effect)

- 可以在 effect 中访问到组件的 props 和 state（闭包机制）
- **每次渲染后都执行**（第一次渲染之后和每次更新之后都会执行）

```js
useEffect(() => {
  document.title = `You clicked ${count} times`;
});
```
注意：
- 每次传递给 useEffect 的，都是一个新的 effect，新的会替换掉之前的。
- React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect

### 清除 Effect
为防止内存泄漏，在组件卸载前会清除 effect。只要**在 effect 中返回一个函数**：
```js
let timer;
const refresh = () => {
  // onGet(match.params.id);

  timer = window.setTimeout(() => {
    refresh()
  }, 1000);
}
const clearTimeout = (t) => {
  if (t) {
    window.clearTimeout(t);
    timer = null;
  }
}

useEffect(() => {
  refresh()
  return () => clearTimeout(timer)
}, [])
```
注意：
React 何时清除 effect？ React 会在**组件卸载的时候**执行清除操作。另外，如果组件多次更新渲染，**则执行新的 effect 之前会对上一个 effect 进行清除，组件卸载清除的是最后一个 effect。**


### Effect 的条件执行
每次渲染后都执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决。

而 useEffect 通过传递第二个可选参数（**effect 所依赖的值数组**）来控制：
```js
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // 数组中传递了 effect 依赖的变量 count，仅在 count 更改时调用
```
注意：所有 effect 函数中引用的值都应该出现在依赖项数组中


如果传递一个**空数组（[]）**：
  - 该 effect 只运行一次（仅在组件挂载和卸载时执行）
  - effect 内部的 props 和 state 就会一直持有其初始值
  - 类似于 componentDidMount 和 componentWillUnmount 的思维模式


### Effect 的执行时机

与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。==大多数情况下，effect 不需要同步地执行。在个别情况下，有单独的 useLayoutEffect Hook 供你使用==，其 API 与 useEffect 相同。


# 自定义 Hook
在 React 中有两种流行的方式来共享组件之间的状态逻辑：高阶组件和 render props。

自定义 Hook 也是一种**复用状态逻辑**的方式，它更像是一种**约定**而不是功能。如果**函数的名字以 “use” 开头并在其内部调用其他 Hook**，我们就说这是一个自定义 Hook。

注意：
- 自定义 Hook 必须以 “use” 开头，不然 React 将无法自动检查
- 在两个组件中使用相同的 Hook 不会共享 state：**它不复用 state 本身**。事实上，**Hook 的每次调用都有一个完全独立的 state**


栗子：
```js
import { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);
  
  const handleStatusChange = (status) {
    setIsOnline(status.isOnline);
  };

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  }, [ friendID ]);

  return isOnline;
}
```
使用:
```js
function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    <li style={{ color: isOnline ? 'green' : 'black' }}>
      {props.friend.name}
    </li>
  );
}
```

```js
const friendList = [
  { id: 1, name: 'Phoebe' },
  { id: 2, name: 'Rachel' },
  { id: 3, name: 'Ross' },
];

function ChatRecipientPicker() {
  const [recipientID, setRecipientID] = useState(1);
  const isRecipientOnline = useFriendStatus(recipientID);

  return (
    <>
      <Circle color={isRecipientOnline ? 'green' : 'red'} />
      <select
        value={recipientID}
        onChange={e => setRecipientID(Number(e.target.value))}
      >
        {friendList.map(friend => (
          <option key={friend.id} value={friend.id}>
            {friend.name}
          </option>
        ))}
      </select>
    </>
  );
}

```


# 常见面试题
## 说一下对 React Hook 的理解（重要）
1. 为什么引入 Hook，主要解决什么问题？
2. 实际项目中用过哪些 Hook？
3. 它的实现原理，和生命周期有哪些区别
  ==实现原理？？？==

