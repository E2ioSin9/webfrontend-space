目录

[TOC]

按照组件/模块管理的方式来构建程序，也就是把一个程序划分为一个个的组件来单独处理。

# 函数组件
1. 基础语法
- 接收一个唯一带有数据的 “props”（代表属性）对象（不传递是一个空对象）
  + children：`是一个不透明的数据结构`，可能是任何类型
    + 组件没有子元素（单闭合）时，是 undefined
    + 组件有子元素（双闭合）时，可能是一个值(字符串、对象)或一个数组
- 并返回一个 React 元素
- 本质上就是 JavaScript 函数
```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
ReactDOM.render(<div>
    <Welcome />
    <Welcome name='CHEN'>
        <span>1</span>
    </Welcome>
</div>, root);
```
注意：
- 在 JS 文件中，凡是用到 JSX 结构的，都要引入 React，因为需要基于它的 createElement 把 JSX 进行解析渲染。
- `React.Children 对象`，提供了 map、forEach 等方法专门处理 this.props.children。 [对React children 的深入理解](https://www.jianshu.com/p/d1975493b5ea)


2. 渲染机制
createElement在处理时，遇到一个组件，type就不再是字符串标签名，而是一个函数（类），但是属性还是存在props中的。
```
{
	type:Dialog,//=>组件Dialog
	props:{
		lx:1,
		con:'xxx',
		children:一个值或一个数组
}
```

==render渲染时，需要做处理==：
- 首先判断type的类型，如果是字符串，就创建一个标签元素，如果是函数或者类，就`把函数执行，把props中的每一项（包含children）传递给函数`。
- 在执行函数时，把函数中return的JSX转换为新对象（通过createElement），然后把这个对象返回。紧接着render按照以往的渲染方式，创建DOM元素，插入到指定的容器中。


# class 组件
1. 基础语法：使用 ES6 的 class 来定义组件：
- 必须有一个 render() 的方法，返回一个 JSX 元素
- super() 相当于 ==React.Component.call(this)==
  function Component(props, context, updater) { ... }
  
```js
class Welcome extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```
注意：
- `super()` 与 `super(props)`的区别：传入 props 是，将传递的属性挂载到子类的实例上，在 constructor 中可以使用 this.props；不传，this.props 拿到的是 undefined。super() 仅仅影响的是在 constructor 中获取 this.props；
- 执行完成 constructor，react 已经帮我们把传递的属性接收，并且挂载到实例上，其它生命周期函数中都可以使用 this.props


# 面试高频题目


## 继承类式（Component类）
1. 两种创建类方式，在渲染机制上的区别：
基于createElement把JSX转换为一个对象，当render渲染这个对象时，遇到type是一个函数或者类，不是直接创建元素，而是先把方法执行：
- 函数声明式组件：就把它当做`普通方法执行`（严格模式下，方法中的this是`undefined`），把函数返回的JSX元素（也是解析后的对象）进行渲染。
- 类声明式组件：把`当前类new执行`，创建类的一个实例（当前本次调取的组件就是它的一个实例），执行constructor之后，会执行this.render()，把render中返回的JSX拿过来渲染。


不管是哪种方式，最后都会把解析出来的`props属性对象作为实参`传递给对应的函数或者类。




## 应用
函数声明式：
- 操作简单
- 能实现的功能，只是简单的调取和返回JSX而已
- 函数式组件可以理解为`静态组件`（组件的内容调取是就已经固定了，很难修改）
所谓函数式组件是静态组件：和执行普通函数一样，调取一次组件，就把组件中的内容获取到，插入到页面中。如果不重新调取组件，显示的内容是不会发生任何改变的。
适用于：`调取一次组件，以后组件中的内容不会再次改变的情况`，例如，获取数据，绑定HTML
```
function Clock() {
    return <section>
        <h3>当前北京时间是：</h3>
        <div style={{fontSize: '20px', lineHeight: '2'}}>
            {new Date().toLocaleString()}
        </div>
    </section>;
}

setInterval(() => {
    ReactDOM.render(<Clock/>, root);
}, 1000);
```


继承类式：
- 操作相对复杂一些，但是可以实现更为复杂的业务功能
- 能够使用生命周期函数操作业务
- 继承类式，可以基于组件内部的状态（state）来动态更新渲染组件的情况
```
class Clock extends React.Component {
    constructor() {
        super();
        //=>初始化组件的状态
        this.state = {
            time: new Date().toLocaleString()
        };
    }
    componentDidMount() {
        setInterval(() => {
            this.setState({//异步操作
                time:new Date().toLocaleString()
            },()=>{
            });
        }, 1000);
    }
    render() {
        return <section>
            <h3>当前北京时间是：</h3>
            <div style={{fontSize: '20px', lineHeight: '2'}}>
                {this.state.time}
            </div>
        </section>;
    }
}
ReactDOM.render(<Clock/>, root);
```