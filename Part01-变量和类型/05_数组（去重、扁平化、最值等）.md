目录

[TOC]

# 数组常用方法
1. **增删改 push/pop/unshift/shift/splice**
  - 返回值：增加返回数组最新的长度，删除返回被删除的那一项
  - 直接修改原数组
2. **截取 slice**
3. **位置 indexOf/lastIndexOf**
  - 作用：检测给定项在在数组中`第一次`或者`最后一次`出现位置的索引
  - 返回：`index 或 -1`

4. **合并 concat**
  - 作用：合并一个或多个值、数组
  - 返回新数组，原数组不变
  [].concat(ary1, ary2) 等同于 ES6 的 [...ary1, ...ary2]

5. **includes**：返回：true/false

6. **转换为字符串 toString/join**
  - 返回：toString返回一个`逗号`分隔的字符串 / join 以传入分隔符连接，原数组不变
  ary.toString()/ary.join()/ary.join(',')三种写法等同
7. **重排序 reverse/sort**


## splice 和 slice 的区别
> splice(n,m,x,...): 从 n 开始删除 0 项或 m 项，然后插入... 
>  - 作用：对原数组，删除指定项、再插入
>  - 返回值：被删除的项组成的数组
>  - 直接修改原数组

1）`删除数组最后一项`，有几种方法：
ary.pop()
ary.splice(ary.length-1)
ary.length--
不建议使用delete删除：delete ary[ary.length-1]

2）`向数组末尾追加新的内容`，有几种方法：
ary.push(val)
ary.splice(ary.length,0,val)
ary[ary.length]=val



> slice(n,m): 截取从索引 n 到 m，`不包含末尾`
>  - 作用：截取
>  - 返回值：一个新数组
>  - 原数组不变
>  - 支持**负数索引**，负数运算规则：数组的总长度 + 负数索引

ary.slice(0) 或 ary.slice() 可实现数组深克隆。

## 检测数组中是否包含某一项
- ary.indexOf(val) > -1
- ary.includes(val) === true

indexOf()使用 === 进行比较，includes()能够识别 NaN
```js
[1, 2, NaN].includes(NaN) // true
[1, 2, NaN].indexOf(NaN) // -1
```

## reverse / sort
- reverse
作用：把数组倒过来排列

- sort
作用：排序
参数：无 或 函数
直接修改原数组

==sort在不传递参数的情况下，只能处理同位数：==
当不传入参数的时候，sort()方法默认先调用每个数组项的toString()转型方法，然后按照字符串Unicode编码顺序来对字符串进行排序。
```js
var ary = [18,1,23,27,2,35,3,56];
ary.sort();//[1,18,2,23,27,3,35,56]
```

>内置sort方法的原理：如果数组存储的都是数字，数组当前项（a）减去下一项（b），如果`返回值大于0`，则a、b交换位置，如果`返回值小于等于0`，则a、b不交换位置。
```js
var ary = [18, 1, 13, 1, 27, 2, 3, 5];
ary.sort(function (a, b) {
    return 1;
});
console.log(ary);//=>[5, 3, 2, 27, 1, 13, 1, 18]
```


# 迭代方法
1. **every/some/filter/map/forEach**
  - 参数：2参（callback , obj），callback：3参（item, index, array），obj 可以修改this

2. **find/findIndex**
  - 作用：找出`第一个`符合条件的数组成员，可识别 NaN
  - 参数：回调函数，返回 true，表示找到了，停止循环
  - 返回：find `返回找到那一项`，找不到返回 `undefined`，findIndex 返回 index/-1
  不修改原数组
```js
[1, -4, -5, 10].find((n, index, ary) => n < 0)
// -4
```
3. **reduce/reduceRight**


## for-in、for-of、for、forEach 的区别
for-in 既可以遍历数组，也可以遍历对象。如果遍历数组，key 会变成 string 类型的，数组作为一个对象的属性也可以打印出来。
for-of 只能遍历数组，不能遍历对象。
forEach: 不支持return
```js
let ary = [1, 2, 3, 4, 5];
ary.b = 100;
for (let key in ary) {
    console.log(typeof key);//=>string
    console.log(key);//=>0 1 2 3 4 b
}
//=>forEach
ary.forEach((item)=>{
    console.log(item);//=>1 2 3 4 5
});
//=>for-of
for(let val of ary){
    console.log(val);//=>1 2 3 4 5
}
```
那怎么使用 for-of 来操作对象呢？可使用`Object.keys([对象])`方法获取对象的所有 key
```js
//=>操作对象
let obj = {
    name: 'chen',
    age: 18
};
for (let key in obj) {
    console.log(key);
}
for (let val of Object.keys(obj)) {
    console.log(val); //=>"name"  "age"
    console.log(obj[val]); //=>'chen' 18
}
```

## reduce
作用：对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。
参数：
- 2参（callback , initialValue）
	+ callback：4参（pre, cur, index, array）
	返回：本次回调函数 **返回的结果会作为下一次的 pre 的初始值**，没有返回的是 undefined
	+ initialValue：可选，pre 的初始值，不提供使用数组的第一个元素作为累加的初始值

返回：返回累计处理的结果
原数组不变


无 initialValue: cur 从索引 1 开始
```js
const result = [0, 1, 2, 3].reduce(function (pre, cur) {
    console.log(pre, cur);
    //=>0 1
    //=>100 2
    //=>100 3

    return 100;
});
console.log(result ); //=>100
```

有 initialValue: cur 从索引 0 开始
```js
const sum = [0, 1, 2, 3].reduce(function (pre, cur) {
    console.log(pre, cur);
    //=> 10 0
    //=> 10 1
    //=> 11 2
    //=> 13 3

    return pre + cur;
}, 10);
console.log(sum); //=>16
```



# 常见面试题
## 数组中用过哪些方法？
- push、pop、unshift、shift 的区别
- splice 和 slice 的区别
- filter、map、find、forEach 的区别
- for-in、for-of、for、forEach 的区别
- split 和 join 的区别（反转）
从功能、返回值，是否会修改原数组这几个方面回答

=> 数组的 API，哪些是纯函数？
纯函数：1. 不改变原数组；2. 返回一个新数组
concat、filter、map、slice


## 数组去重 *
`见01-unique-ary.js`
```js
const arr = [1, 1, 2, 3, 5, 4, 5, 3, 4, 'a', 'b', 'a'];
//方法一：使用 […new Set(arr)] 或 Array.from(new Set(arr))

//方法二：使用 forEach() 和 includes()
const newArr = []
arr.forEach(item => {
	if (!newArr.includes(item)) {
		newArr.push(item);
	}
});

//方法三：使用 reduce() 和 includes()
let newArr = arr.reduce((pre, cur) => {
	if (!pre.includes(cur)) {
		pre.push(cur);
	}
	return pre;
}, []);

//方法四：使用 filter() 和 indexOf()
const newArr = arr.filter((item, index, array) => array.indexOf(item) === index);
```

## 手写 flatern（数组拍平）
```js
const ary1 = [1, 2, [3, 4], 5];

Array.prototype.concat.apply([], ary1); // [1, 2, 3, 4, 5]
// 等同于 [].concat(...ary1)

// 更深层次的数组呢
const arr2 = [1, 2, [3, [4, 5]], 6]; // [1, 2, 3, [4, 5], 6]
``` 
对 深层次的数组，肯定要使用递归多次拍平：
```js
function flat(ary) {
    const isDeep = ary.some(item => Array.isArray(item));
    
    if (!isDeep) {
        return ary;
    }
    
    const res = Array.prototype.concat.apply([], ary);

    return flat(res);
}

const res = flat([1, 2, [3, [4, 5]], 6]);
console.log(res);
```

## 知道 concat 吗？手写一个
```js
//=>参数不确定有多少个，类型也不确定
Array.prototype.myConcat = function myConcat() {
    //=>this：当前数组实例
    let _this = this.slice();
    for (let i = 0; i < arguments.length; i++) {
        let item = arguments[i];
        if (Array.isArray(item)) {
            // [].push.apply(_this, item);
            _this.push(...item);
        } else {
            _this.push(item);
        }
    }
    return _this;
};

const ary1 = [1, 2],
    ary2 = [3, 4, 5],
    str = 'chen';
const newAry = ary1.myConcat(ary2, str);
console.log(newAry);
```

## map 网红题
```js
[10, 20, 30].map(parseInt)
// 等同于
[10, 20, 30].map((value, index)=> {
    return parseInt(value, index) // index 进制
})
parseInt(10, 0) parseInt(10, 10) // 10
parseInt(20, 1) // NaN
parseInt(30, 2) // NaN
```

## 知道 reduce 吗？用 reduce 实现一个数组求和
```js
//=>使用 reduce
	const objArr = [{x: 1}, {x: 2}, {x: 3}];
	const sum = objArr.reduce((pre, cur) => pre + cur.x, 0);

//=>使用 for-of
  for (let item of objArr) {
      sum += item.x;
  }
```
需求一：对象型数组，使用 reduce 计算购物车中商品的总价格
```js
const cartData = [{price: 20, count: 2}, {price: 15, count: 3}, {price: 8, count: 10}];
const totalMoney = cartData.reduce(function (pre, cur) {
    //=>0 + 40
    //=>40 + 45
    //=>85 + 80
    return pre + cur.price * cur.count;
}, 0);
console.log(totalMoney); //=>165
```


需求二：将二维数组展开为一维
```js
const flat = [[0, 1], [2, 3], [4, 5]].reduce((pre, cur) => {
    return pre.concat(cur);
});
console.log(flat); //=>[0, 1, 2, 3, 4, 5]
```

## 求 a、b、c 三个数组的交集、并集、差集（京东）
```js
const a = [1, 2, 3, 4, 5, 7, 9],
    b = [1, 3, 5, 7, 9],
    c = [1, 2, 4, 6, 8];
// 求 a∩b∩c => [1]   a∪b∪c => [1-9]   a≠b≠c => [6,8]


// 1. 并集
const d = a.concat(b, c),
    unionResult = [...new Set(d)];
console.log(unionResult);

// 2. 统计数组中元素出现的次数
const countObj = d.reduce((pre, cur) => {
    if (pre.hasOwnProperty(cur)) {
        pre[cur]++;
    } else {
        pre[cur] = 1;
    }
    return pre;
}, {});
console.log(countObj);

// 3. 交集
const intersection = Object.keys(countObj).filter(item => countObj[item] === 3).map(item => parseFloat(item));

console.log(intersection);

// 4. 差集
const diffResult = Object.keys(countObj).filter(item => countObj[item] === 1).map(item => parseFloat(item));

console.log(diffResult);
```


## 随机打乱一个数组
原理：基于 sort 排序，`每一次随机返回一个大于0或小于等于0的值`，从而随机决定是否交换位置。
```js
const ary = [1, 2, 3, 4, 5, 6, 7, 8];
ary.sort(function (a, b) {
    return Math.round(Math.random()*(m-n)+n);//=>m可取+5，n可取-5
});
console.log(ary);//=>每一次执行都会随机生成一个顺序
```

