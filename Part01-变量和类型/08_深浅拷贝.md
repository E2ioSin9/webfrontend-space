目录

[TOC]

# 浅拷贝、深拷贝
针对像 Object, Array 这样的复杂对象的。


## 浅拷贝
浅拷贝：拷贝的是一份引用，而不拷贝对象本身。新旧两个对象指向同一个堆内存，修改其中一个，则另一个也会改变

1. `Object.assign(target, source)`：将所有可枚举属性的值从一个或多个源对象（source）拷贝到目标对象（target）。返回 target。
```js
const obj1 = { a: 0 , b: { p: 0}}; 
const obj2 = Object.assign({}, obj1); 
obj1.a = 1; 
console.log(obj2.a); // 0
obj2.b.p = 33;
console.log(obj1, obj2); // { a: 1, b: { p: 33}}  { a: 0, b: { p: 33}}
```
2. 数组的 slice、concat、filter、map 等返回新数组时，浅拷贝发生在 这一项是引用类型时，如果数组内部全是基本类型值，就是深拷贝。
```js
const ary1 = [1, 2, { a: 1 }]

const ary2 = ary1.map(p => p) // ary1[2] === ary2[2] => true

ary2[2].a = 'p'
console.log(ary1[2].a) // p

const ary3 = [].concat(ary1)
ary3[2].a = 'm'
console.log(ary1[2].a, ary2[2].a) // m m
```


## 深拷贝
深拷贝：则是开辟新的堆内存，新旧两个对象对应两个不同的地址。修改一个对象的属性，不会改变另一个对象的属性。

1. `b = JSON.parse(JSON.stringify(a))`
2. `ary.slice()` ary 内部全是基本类型


	
# 实现一个深拷贝

```js
// //=>判断对象的类型
// const isClass = (o) => {
//     return Object.prototype.toString.call(o).slice(8, -1);
// };
function deepClone(obj = {}) {
    if (typeof obj !== 'object' || obj == null) {
        // obj 是 null，或者不是对象和数组，直接返回
        return obj
    }

    // 初始化返回结果
    let result
    if (obj instanceof Array) {
        result = []
    } else {
        result = {}
    }

    for (let key in obj) {
        // 保证 key 不是原型的属性
        if (obj.hasOwnProperty(key)) {
            // 递归调用！！！
            result[key] = deepClone(obj[key])
        }
    }

    // 返回结果
    return result
}

// test array
let o1 = [1, 2, [3, 4], {a: 1}];
let o2 = deepClone(o1);
o2[2].push(5);
o2[3].b = 2;
console.log(o1, o2, o1 === o2);

// test object
const obj1 = { a: 0 , b: { p: 0}};
const obj2 = deepClone( obj1); 
obj1.b.p = 33;
console.log(obj2); // { a: 0, b: { p: 0}}
```

```js
const ary = [11, 22, 33];

for (let key in ary) {
    console.log(key, ary[key])
}
// 0 11
// 1 22
// 2 33
```



# 常见面试题
## 什么是深拷贝、浅拷贝？ 手写深拷贝
## 手写深度比较，模拟 lodash 的 isEqual
```js
function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
}
function isEqual(obj1, obj2) {
    if (!isObject(obj1) || !isObject(obj2)) {
        // 值类型（一般不会比较函数）
        return obj1 === obj2
    }
    if (obj1 === obj2) {
        return true;
    }
    // 两个都是引用类型，并且不相等
    // 1. 先取出 obj1 和 obj2 的 keys，比较个数
    /**
    * Object.keys([11, 22]) -> ["0", "1"]
    * Object.keys({ a: 1}) -> ["a"]
    **/
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
        return false;
    }
    // 2. 以 obj1 为基准，和 obj2 一起递归比较
    for (let key in obj1) {
        // 比较当前 key 的 val - 递归
        const res = isEqual(obj1[key], obj2[key]);
        if (!res) {
            return false;
        }
    }
    // 3. 全相等
    return true;
}

// 用法
const object = { a: 1, b: { x: 100 }};
const other = { a: 1, b: { x: 100 }};
 
isEqual(object, other);
// => true
 
object === other;
// => false
```
