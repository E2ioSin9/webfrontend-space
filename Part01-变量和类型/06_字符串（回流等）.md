目录

[TOC]

字符串的不变性：每一次操作都是基于值进行，不像数组一样是基于空间地址操作，所以不存在原字符串是否改变，肯定都是不变的。

# 字符串常用方法
1. 位置 **indexOf / lastIndexOf** 同数组
2. 截取 **slice / substring / substr**
3. 大小写转换 **toUpperCase / toLowerCase**
4. 将字符串拆为数组 **split**，对应数组的 join
5. 替换 replace
6. trim
7. fixed
8. match/search

## 截取 slice / substring / substr

- slice 同数组
  字符串深克隆并没有什么意义

- substring
  和 slice 的唯一的区别在于：slice 支持负数索引，substring 不支持，返回`空字符串`

- substr
  substr(n,m) 从索引 n 开始截取 m 个字符
  支持负数索引，总长度+负数索引。

```js
const str = 'test:string-method';
str.slice(2, 7); //=>'st:st'
str.slice(2); //=>'st:string-method'
str.slice(); //=>'test:string-method'

str.substring(-3, -1); //=>''
str.slice(-3, -1); //=>'ho'
str.substr(2, 3); //=> 'st:'
```

## replace

- replace
  作用：替换
  参数：2 参，原有字符、要替换的新字符
  返回：替换后的字符串
  注意：**在不使用正则的情况下，每执行一次，只能替换一个**

```js
let str = 'chen2019chen杨2020';
str = str.replace('chen', '陈'); //'陈2019chen杨2020'
str = str.replace('chen', '陈'); //'陈2019陈杨2020'

//使用正则一步搞定
str = str.replace(/chen/g, '陈');
```

## chatAt / chatCodeAt（了解）

chatAt 根据索引获取指定位置的字符
chatCodeAt 不仅获取字符，还获取对应的 Unicode 编码值（ASC II 码值，返回的是十进制的）
参数：index

fromCharCode 返回的编码对应的字符

```js
var str = 'chen';
str.charCodeAt(0); //99
String.fromCharCode(99); //'c'
```

# 时间字符串格式化
有一个时间字符串"2018-4-4 16:26:8"，获取它的"04月04日 16时26分"
`见01-time-string.js`
==万能方法==：
```js
~function (pro) {
    pro.formatTime = function (template) {
        template = template || '{0}年{1}月{2}日 {3}时{4}分{5}秒';
        var ary = this.match(/\d+/g);
        template = template.replace(/\{(\d+)\}/g, function () {
            var n = arguments[1],
                val = ary[n] || '0';
            val < 10 ? val = '0' + val : null;
            return val;
        });
        return template;
    }
}(String.prototype);
```
```js
String.prototype.myFormatTime = function myFormatTime(template = '{0}年{1}月{2}日 {3}时{4}分{5}秒') {
	let ary = this.match(/\d+/g).map(item => (item < 10 ? '0' + item : item));
	return template.replace(/\{(\d)\}/g, (...[, index]) => ary[index] || '00');
};

let str = "2018-4-30";
console.log(str.myFormatTime('{1}-{2} {3}:{4}'));//04-30 00:00
```

# 常见面试题

## 字符串用过哪些方法

- slice、substring、substr 的区别

## 将 url 参数解析为 JS 对象
`见01-URL-string.js`

```js
// URL地址问号传参解析
const str = 'http://www.baidu.cn/stu/?lx=1&name=AA&sex=man';
// ? 后后边要字符串 location.search
// # 号后边的称为哈希(HASH)值，这个值可能有，可能没有
// 期望结果：{lx: "1", name: "AA", sex: "man"}
```

- 方法一：传统字符串方法：

```js
function queryURLParameter(str) {
  const res = {};
  const searchStr = url.substr(url.indexOf('?') + 1);
  searchStr.split('&').forEach((item) => {
    const [key, val] = item.split('=');

    res[key] = val;
  });

  return res;
}
queryURLParameter(url)
```

- 方法二：URLSearchParams

```js
function queryURLParameter(url) {
  const res = {};
  const params = new URLSearchParams(url.substr(url.indexOf('?')));

  for (let [key, val] of params) {
    res[key] = val;
  }

  return res;
}

queryURLParameter(url);
```
- 方法三：使用 a 标签，操作 DOM 元素对象的属性
步骤：
1）创建一个a标签，把需要解析的地址当做 a 标签的 href 赋值
//=>a 标签无需添加到页面中，我们只是想要利用它的属性而已
2）a 元素对象的 hash / search 两个属性分别存储了哈希值和查询参数值
3）分别解析出 hash 和参数即可
```js
function queryURLParameter(str) {
    const link = document.createElement('a');
    
    link.href = str;

    const searchStr = link.search.slice(1),//=>"lx=1&name=AA&sex=man"
        searchAry = searchStr.split('&'),//=>["lx=1", "name=AA", "sex=man"]
        obj = {};

    for (let val of searchAry) {
        const [key, value] = val.split('=');
        
        obj[key] = value;
    }
    
    // 没有'#'号时，hash为空字符串，在if语句中会自动转为false
    if (link.hash) {
        const hashStr = link.hash.slice(1);//=>"teacher"
        
        obj.HASH = hashStr;
    }
    return obj;
}

queryURLParameter(str);
```

## 写一个函数，判断字符串是否回文（好未来）
**回文(Palindromes)**，就是指倒着念和顺着念都是相同的，根据中心左右对称的字符串。

```js
function isPalindromes(str) {
  if (typeof str !== 'string') {
    return false;
  }

  return str.split('').reverse().join('') === str;
}
isPalindromes('abcba'); //true
isPalindromes('abcdfc'); //false
isPalindromes('aaaaa'); //true
isPalindromes('上海自来水来自海上'); // true
```
