目录

[TOC]
# 基本语法
- 小驼峰式（camelCase），原生 camelcase
- 传入一个函数作为事件处理函数，而不是一个字符串
```js
<button onClick={this.onHandleClick}>
  {this.state.isToggleOn ? 'ON' : 'OFF'}
</button>
```


# bind this
==在 JS 中，class 的方法默认不会绑定 this==。如果不绑定 this，在 onHandleClick 中获取 this 是 undefined。==？？？==
bind this 只是 修改方法的 this 指向。
```js
class EventDemo extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true };

    // 修改方法的 this 指向
    this.onHandleClick = this.onHandleClick.bind(this);
  }

  onHandleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.onHandleClick}>
        {this.state.isToggleOn ? "ON" : "OFF"}
      </button>
    );
  }
}
```
两种方式可以解决:
- 箭头函数
```js
onHandleClick = () => {
  this.setState(state => ({
    isToggleOn: !state.isToggleOn
  }));
}
```
- 在 JSX 的回调中使用箭头函数
```js
<button onClick={() => this.onHandleClick()}>
  {this.state.isToggleOn ? "ON" : "OFF"}
</button>
```
- 另一种 bind 方法
```js
<button onClick={this.onHandleClick.bind(this)}>
  {this.state.isToggleOn ? "ON" : "OFF"}
</button>
```

# 向事件处理程序传递参数
1. 使用 bind(this, a, b)
2. JSX 的回调使用箭头函数传
```js
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button> // 不推荐
```
注意：最后追加一个参数，即可接受 event

# event
## 栗子
阻止 a 标签默认打开链接的行为：

1. 原生 Html 是这样的：通过返回 false 的方式
```js
<a href="#" onclick="console.log('The link was clicked.'); return false">
  Click me
</a>
```

2. React 中: 显式的调用 preventDefault()
```js
function ActionLink() {
  const onHandleClick = (event) => {
    event.preventDefault(); // 阻止 a 标签默认打开链接的行为
  }

  return (
    <a href="https://cn.bing.com/" onClick={onHandleClick}>
      Click me
    </a>
  );
}
```

## SyntheticEvent
>**event 并不是原生 event，是 React 封装的合成事件对象**：
> - event 是 **SyntheticEvent**，它模拟出来 DOM 事件所有能力。
> - **event.nativeEvent** 可以获取原生事件对象，其  \_\_proto__.constructor 是 MouseEvent。
> - 所有的事件，都被挂载到 **document** 上
> - 不同于 Vue 事件，也不同于 DOM 事件

Vue 的 event 是原生的，事件被挂载到当前元素上。
```js
const onHandleClick3 = event => {
    console.log('event.target', event.target) // 指向当前元素，即当前元素触发
    console.log('event.currentTarget', event.currentTarget) // 指向当前元素，假象！！！

    
    console.log('event', event) // 不是原生的 Event ，原生的是MouseEvent
    console.log('event.__proto__.constructor', event.__proto__.constructor)

    // 原生 event 如下：
    console.log('event.nativeEvent', event.nativeEvent)
    console.log('event.nativeEvent.target', event.nativeEvent.target)  // 指向当前元素，即当前元素触发
    console.log('event.nativeEvent.currentTarget', event.nativeEvent.currentTarget) // 指向 document ！！！
  };
```

![event](https://user-images.githubusercontent.com/22387652/84558546-3541de00-ad66-11ea-8d1f-40545f1cbde0.png)


![SyntheticEvent](https://user-images.githubusercontent.com/22387652/87444840-e2d83380-c629-11ea-9c57-f129dcc0b227.png)

dispatchEvent：派发事件，通过 target 找到所在组件，找到谁绑定的对应的事件处理函数

**为什么要 引入合成事件？**
- 摆脱（没有完全摆脱，需要 DOM 触发和监听） DOM 事件机制，有更好的兼容性和跨平台
- 全部挂载到 document，减少内存消耗（比如瀑布流、无限加载的列表绑定每一个的事件，挂载到在最外层父元素），避免频繁解绑
- 便于事件的统一管理（如事物机制）


# 常见面试题
1. 关于 event 参数
2. 说一说 React 的合成事件机制，为什么引入？
3. 与 DOM 事件的区别？
  - 所有事件都挂载到 document 上
  - event 不是原生的，是 SyntheticEvent 合成事件对象
  - dispatchEvent 机制