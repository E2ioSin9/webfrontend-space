目录

[TOC]


# 单线程
## 进程与线程
什么是进程？每一个应用程序可以理解为一个进程。

**进程大线程小**：一个进程包含多个线程。在一个程序（进程中）中，可以分配多个线程去同时完成多项任务。
例如，浏览器打开一个 HTML 页面就打开一个进程，加载页面时，浏览器分配一个线程去计算 DOM 树，分配其它的线程去加载其它的资源文件...再分配一个线程去自上而下执行 JS 代码。

## JS 是单线程的
> **单线程的特点：同一时间只能干一件事情**

**JS 和 DOM 渲染共用同一个线程**。因为 JS 会去修改 DOM 结构，当 JS 执行时 DOM 渲染必须停止，当 DOM 渲染时 JS 必须暂停执行，不能同时进行。

但**浏览器是多线程的**，浏览器是如何规划同步异步机制的呢？？？
本质上用**单线程的机制模拟出一个多线程的效果**。JS中的异步编程仅仅是根据某些机制来**管控任务的执行顺序**，不存在同时执行两个任务这一说法。


# 什么是异步
同步：任务是按顺序依次处理，当这件事没有彻底做完，就不能去干下一件事
异步：当前这件事没有彻底完成，需要等待一段时间才能继续处理，此时我们不等，继续执行下面的任务，当后面的任务完成后，再去把没有彻底完成的事情完成。

**基于 JS 单线程语言，异步不会阻塞代码的执行。同步会阻塞代码执行。**


# 任务队列
单线程就意味着，所有任务需要排队。

所有任务可以分成两种：
- **同步任务**（synchronous）：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
- **异步任务**（asynchronous）：不进入主线程、而进入"任务队列"（Callback Queue）的任务，只有任务队列通知可以执行，该任务才会进入主线程执行。

**任务队列（Callback Queue）**是异步任务执行之前的排队等候区。

主线程任务在执行时，会形成一个调用栈（Call Stack）。每一项任务从执行到完成，有一个**进栈->出栈**的过程。

# Event Loop
JS 在处理异步操作时，利用的是事件循环机制。

主线程从"任务队列"中查找事件，这个过程是循环不断的，这种运行机制又称为**Event Loop（事件循环／事件轮询）**。

1. 在主线程中自上而下执行时，遇到同步任务，推入调用栈（Call Stack）执行，遇到异步任务，会先“记录”下来，等待时机（例如定时器、ajax 请求等）
2. 时机一到，将异步任务推入 等待队列（Callback Queue）
3. 如果 Call Stack 空闲
  - 首先，**执行当前微任务**（如果有）
  - 其次，**尝试 DOM 渲染**（如果 DOM 有更新）
  - 然后 **Event Loop 开始工作，轮训查找**，哪个任务达到条件，这个任务推入 Call Stack 执行。
4. 当 Call Stack 再次空闲，然后继续重复以上步骤。

<img width="597" alt="Event Loop" src="https://user-images.githubusercontent.com/22387652/90975024-39a72600-e563-11ea-9e83-d71a252f61ca.png">

从 Event Loop 的角度来分析：
setTimeout 的回调 是放在 浏览器的 timer 模块（Web APIs）等待时机，推入 Callback Queue。
Promise 是 ES 规范，不是 W3C 规范，不会经过 Web APIs，执行 Promise 等待时机，直接推入 Micro Task Queue。

一个 Loop 执行一个 宏任务和所有的微任务
=》如果 setTimeout 嵌套 setTimeout，会阻塞流程吗？不会
如果很多 promise，会阻塞流程吗？会


进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。

```js
setTimeout(function() {
    console.log('setTimeout');
})

new Promise(function(resolve) {
    console.log('promise');
}).then(function() {
    console.log('then');
})

console.log('console');
```

- 这段代码作为宏任务，进入主线程。
- 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)
- 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。
- 遇到console.log()，立即执行。
- 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。
- ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。
结束。

事件循环，宏任务，微任务的关系如图所示：

![宏任务，微任务](https://user-images.githubusercontent.com/22387652/92194962-739af500-ee9e-11ea-9155-8f5313a14db7.png)


https://juejin.im/post/6844903512845860872#heading-1
https://www.cnblogs.com/chenwenhao/p/11253403.html#_label6


# 常见的面试题
1. 什么是异步？同步和异步的区别是什么？

2. 前端使用异步的场景有哪些？

3. 请描述 Event Loop（事件循环／事件轮询）的机制，可画图
   - DOM 渲染在里边的
   - 一个 Loop 执行几次宏任务，几次微任务
