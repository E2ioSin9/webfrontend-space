目录

[TOC]


# 单线程
## 进程与线程
什么是进程？每一个应用程序可以理解为一个进程。

**进程大线程小**：一个进程包含多个线程。在一个程序（进程中）中，可以分配多个线程去同时完成多项任务。
例如，浏览器打开一个 HTML 页面就打开一个进程，加载页面时，浏览器分配一个线程去计算 DOM 树，分配其它的线程去加载其它的资源文件...再分配一个线程去自上而下执行 JS 代码。

## JS 是单线程的
> **单线程的特点：同一时间只能干一件事情**

**JS 和 DOM 渲染共用同一个线程**。因为 JS 会去修改 DOM 结构，当 JS 执行时 DOM 渲染必须停止，当 DOM 渲染时 JS 必须暂停执行，不能同时进行。

但**浏览器是多线程的**，浏览器是如何规划同步异步机制的呢？？？
本质上用**单线程的机制模拟出一个多线程的效果**。JS中的异步编程仅仅是根据某些机制来**管控任务的执行顺序**，不存在同时执行两个任务这一说法。


# 什么是异步
同步：任务是按顺序依次处理，当这件事没有彻底做完，就不能去干下一件事
异步：当前这件事没有彻底完成，需要等待一段时间才能继续处理，此时我们不等，继续执行下面的任务，当后面的任务完成后，再去把没有彻底完成的事情完成。

**基于 JS 单线程语言，异步不会阻塞代码的执行。同步会阻塞代码执行。**


# 任务队列
单线程就意味着，所有任务需要排队。

所有任务可以分成两种：
- **同步任务**（synchronous）：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
- **异步任务**（asynchronous）：不进入主线程、而进入"任务队列"（Callback Queue）的任务，只有任务队列通知可以执行，该任务才会进入主线程执行。

**任务队列（Callback Queue）**是异步任务执行之前的排队等候区。

主线程任务在执行时，会形成一个调用栈（Call Stack）。每一项任务从执行到完成，有一个**进栈->出栈**的过程。

# Event Loop
主线程从"任务队列"中查找事件，这个过程是循环不断的，这种运行机制又称为**Event Loop（事件循环／事件轮询）**。

1. 在主线程中自上而下执行时，遇到同步任务，推入调用栈（Call Stack）执行，遇到异步任务，会先“记录”下来，等待时机（例如定时器、ajax 请求等）
2. 时机一到，将异步任务推入 等待队列（Callback Queue）
3. 如果 Call Stack 空闲
  - 首先，**执行当前微任务**（如果有）
  - 其次，**尝试 DOM 渲染**（如果 DOM 有更新）
  - 然后 **Event Loop 开始工作，轮训查找**，哪个任务达到条件，这个任务推入 Call Stack 执行。
4. 当 Call Stack 再次空闲，然后继续重复以上步骤。

<img width="597" alt="Event Loop" src="https://user-images.githubusercontent.com/22387652/90975024-39a72600-e563-11ea-9e83-d71a252f61ca.png">

从 Event Loop 的角度来分析：
setTimeout 的回调 是放在 浏览器的 timer 模块（Web APIs）等待时机，推入 Callback Queue。
Promise 是 ES 规范，不是 W3C 规范，不会经过 Web APIs，执行 Promise 等待时机，直接推入 Micro Task Queue。




# 结束
***重学 JS 系列*** 预计 25 篇左右，这是一个旨在帮助大家，其实也是帮助我自己捋顺 JavaScript 底层知识的系列。主要包括变量和类型、执行上下文、作用域及闭包、原型和继承、单线程和异步、JS Web API、渲染和优化几个部分，将重点讲解如执行上下文、作用域、闭包、this、call、apply、bind、原型、继承、Event-loop、宏任务和微任务等比较难懂的部分。让我们一起拥抱整个 JavaScript 吧。

大家或有疑问、或指正、或鼓励、或感谢，尽管留言回复哈！非常欢迎 star 哦！

[点击返回博客主页](https://github.com/chenchen0224/webfrontend-space)
