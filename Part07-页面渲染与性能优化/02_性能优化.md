目录

[TOC]

性能优化的原则：
1）多使用内存、缓存或其他方法
2）减少 CPU 计算量，减少网络加载耗时



# 加载资源优化
## 静态资源的压缩合并
尽量 合并 JS、CSS、img 等资源文件，原理是减少 HTTP 访问次数、可能把合并后的代码进行压缩，减少资源体积。

利用 webpack 等打包工具进行资源的合并与压缩操作，可以大大减小资源的大小，实现页面更快的加载。


### CSS 的 sprite
概念：将多个小图片拼接到一张大图上。后期只要加载大图，通过背景定位的方式展示对应的小图。
优点：
1. 减少HTTP请求数，极大地提高页面加载速度
2. 增加图片信息重复度，提高压缩比，减少图片大小
3. 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 


## 静态资源缓存
采用浏览器和服务器端的缓存技术（304缓存），把一些不经常更新的静态资源文件做缓存处理。

webpack 打包上线后会为静态资源（js css img）加一个 hash 值后缀：
<img width="473" alt=" 缓存例子" src="https://user-images.githubusercontent.com/22387652/91427575-b0f4f680-e890-11ea-8c25-26d615cc88c7.png">

contenthash：根据内容生成一个 hash 的字符串
- 静态资源加 hash 后缀，根据文件内容计算 hash
- 文件内容不变，则 hash 不变，则 url 不变
- url 和文件不变，则会自动触发 http 缓存机制，返回 304。


## 使用 CDN 让资源加载更快
使用更快的网络：CDN 根据不同的区域连接对应的服务器进行优化。
CDN：引用 js、css 等静态资源时，很多时候会使用 CDN 地址。

<img width="531" alt="CDN" src="https://user-images.githubusercontent.com/22387652/91427439-7c813a80-e890-11ea-83ff-25dc3dd671d6.png">




## SSR 服务器端渲染
服务器端把数据和源代码进行拼接，一起返回给客户端，客户端拿到之后直接渲染呈现，不需要再进行字符串拼接，增加页面第一次打开的速度。

淘宝，京东的首屏数据是基于服务器端渲染的。

## 可异步无阻塞加载 JS
基于 script 标签调取 JS 时，可使用 defer 或 asyin 来异步加载。

使用异步获取数据，是为了降低 HTTP 通道的堵塞，不会因为数据没有请求回来耽误下面信息的渲染，提高页面的打开速度（可以这样处理：需要动态绑定数据的区域先隐藏，等数据返回并且绑定完成后再让其显示）

## 资源预加载
页面出现音视频标签，不让页面加载时就去加载这些资源（要不然页面加载速度会变慢）
只需要设置preload ="none"即可，等待页面加载完成，音视频播放时，再去加载音视频资源


# 渲染优化
## CSS 放在 head，JS 放在 body 最下面

1. 为什么把 CSS 文件的加载放在 head 标签中？
如果将 CSS 放在头部，CSS 的加载解析是可以和 HTML 的解析同步进行的。
若将 CSS 样式放到要渲染的 DOM 节点之后，就会出现最开始按照默认样式渲染，等 CSS 加载完后又重新渲染。出现样式跳转、闪动的现象。

2. 为什么把 script 文件放在 body 最底下？
因为遇到 script 会暂停渲染，把先能出来的东西渲染出来，让用户看到内容，然后再加载 JS


## 懶加载（图片懶加载，上滑加载更多）
开始加载页面时，并没有加载真实的图片，而是给第一张占位的背景图，当页面结构和数据都呈现完成后，再加载真实的图片。

比如一个新闻列表（图片列表），希望首屏图片加载完成，随着用户滑动页面时，图片慢慢加载出来。
```js
// <img id="img" src="preview.png" data-src="a.png" />  preview 要足够小
const img = document.getElementById('img')
img.src = img.getAtttribute('data-src') // 当图片即将出现在屏幕上时，给 src 赋值
```

## 避免频繁的 DOM 操作、消耗性能
### 对 DOM 查询进行缓存
```js
// 不缓存 DOM 查询结果
for (let i = 0; i < document.getElementsByTagName('p'); i++) {
    // 每次循环都会计算 length，频繁进行 DOM 查询
}

// 缓存 DOM 查询结果
const pList = document.getElementsByTagName('p');
const length = pList.length;
for (let i = 0; i < length; i++) {
    // 缓存 length，只进行一次 DOM 查询
}
```
未缓存 DOM 查询时，每次循环都要进行 DOM 查询；缓存了 DOM 查询时，只需进行一次 DOM 查询操作，将数值保存在变量中使用即可。

### 频繁 DOM 操作，合并到一起插入 DOM 结构
当`需要动态向页面追加元素`时，基于文档碎片或者把需要增加的所有元素拼接成字符串
- 基于`文档碎片`
文档碎片是在虚拟内存中开辟的一个容器。每当创建一个li，我们首先把它放到文档碎片中，（千万不要放到页面中，避免回流），当我们需要的元素都创建完，把文档碎片一次性打包到页面中。
```js
const listNode = document.getElementById('list');
const frag = document.createDocumentFragment();//=>1.创建文档碎片容器，此时还没有插入到 DOM 树中
for (let i = 0; i < 10; i++) {
    const li = document.createElement('li');
  
    li.innerHTML = `List item + ${i}`;
    frag.appendChild(li);//=>2.每一次把创建的 li 先插入到文档碎片中
}
listNode.appendChild(frag);//=>把文档中的碎片统一插入到 DOM 树中
frag = null;//=>清空 frag
```


## 尽早开始执行 JS，用 DOMContentLoaded 触发

图片、视频等静态资源大小参差不齐，加载完成时间又会有很大的差别，但html 一般很小，加载时间很短，所以用 DOMContentLoaded 替代 window.onload，可以显著提高性能和用户体验。

```js
window.addEventListener('load', function () {
  // 页面的全部资源加载完成才会执行，包括图片、视频等
});
document.addEventListener('DOMContentLoaded', function () {
  // DOM 渲染完即可执行，此时图片、视频等可能还没有加载完成 => 渲染速度更快
});
```



# 体验优化
## 节流 throttle 防抖 debounce

## 骨架屏
第一个为骨架屏，第二个为菊花图，第三个为无优化，可以看到相比于传统的菊花图会在感官上觉得内容出现的流畅而不突兀。

![骨架屏](https://user-images.githubusercontent.com/22387652/92721182-3fd93700-f398-11ea-87c9-12b13ed1e131.gif)



# 其他优化
1. 尽可能使用事件委托（事件代理），来处理事件绑定操作，减少DOM 的频繁操作，其中包括给每一个 DOM 元素做事件绑定
2. 使用 window.requestAnimationFrame（JS中的帧动画）代替传统的定时器动画
3. 尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片（因为字体图标等是矢量图（基于代码编写出来的），放大不会变形，而且渲染速度快，相对比位图要小一些）

4. 减少对DOM的操作，主要是减少DOM的重绘和回流（重排）。
A：关于重排的分离读写
B：使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）



# 常见面试题
重点列出，尽量全面。

## 一万条数据，怎么处理
1. 文档碎片
遍历数据，把对应的数据和结构都添加到文档碎片中，再把文档碎片插入到页面中（优势：减少DOM的回流=>基于字符串拼接也可以）
2. 虚拟DOM：类似于react框架，基于虚拟DOM以及DIFF算法，也可以优化数据绑定
以上两种方案，
->从服务器获取1万条消耗很多时间
->页面渲染1万条也消耗很多时间

3. 异步数据加载：分页加载
需要服务器端提供支持：
- 客户端向服务器端发送一个get请求，传递给服务器：每页展示的条数，当前要展示的页数等信息，例如传递的是?limit=20&page=1（每页展示20条，当前展示第一页）
- 服务器端接收到请求后，在所有的数据中把第一页的20条数据返回给客户端
- 当用户下拉加载更多或点击第二页等页码按钮时，重复第一步，把对应要展示的页码传递给服务器，服务器返回对应页码中的数据。

## 介绍一下 window.requestAnimationFrame（简称 RAF、体验优化）
实现动画流畅，更新频率需要 60 帧/s，即 16.67ms 更新一次视图
- setTimeout 要手动控制频率，而 RAF 浏览器会自动控制
- 后台标签或隐藏 iframe 中，RAF 会暂停，而 setTimeout 依然执行

`见demo`

## CSS 动画和 JS 动画，哪个性能更好？为什么？

## 一次性插入多个 DOM 节点，考虑性能（如何减少 DOM 操作）

## window.onload 和 DOMContentLoaded 的区别？

