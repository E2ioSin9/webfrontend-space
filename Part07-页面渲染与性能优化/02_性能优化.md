目录

[TOC]

性能优化的原则：
1）多使用内存、缓存或其他方法
2）减少 CPU 计算量，减少网络加载耗时

从何入手：加载快、渲染快

# 加载快
1）减少资源体积：压缩代码
webpack 在生产环境下的打包方案：mode: 'production' 压缩打包

2）减少访问次数：合并代码，SSR 服务器端渲染，缓存

合并代码：JS、CSS、img 都可以合并

SSR 服务器端渲染：
服务端把网页和数据一起加载，一起给前端渲染出来
非 SSR（前后端分离）：先加载网页，再加载数据，再渲染数据。

缓存：
<img width="473" alt=" 缓存例子" src="https://user-images.githubusercontent.com/22387652/91427575-b0f4f680-e890-11ea-8c25-26d615cc88c7.png">

contenthash：根据内容生成一个hash的字符串
- 静态资源加 hash 后缀，根据文件内容计算 hash
- 文件内容不变，则 hash 不变，则 url 不变
- url 和文件不变，则会自动触发 http 缓存机制，返回 304。


使用更快的网络：CDN 根据区域连接对应的服务器
CDN：引用 js、css 等静态资源时，很多时候会使用 CDN 地址。

<img width="531" alt="CDN" src="https://user-images.githubusercontent.com/22387652/91427439-7c813a80-e890-11ea-83ff-25dc3dd671d6.png">



# 渲染快
1）CSS 放在 head，JS 放在 body 最下面。
2）尽早开始执行 JS，用 DOMContentLoaded 触发。
3）懶加载（图片懶加载，上滑加载更多）
4）对 DOM 查询进行缓存
5）频繁 DOM 操作，合并到一起插入 DOM 结构
6）节流 throttle 防抖 debounce（体验性优化）




CSS 的 sprite
概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸
调节需要显示的背景图案。
优点：
1. 减少HTTP请求数，极大地提高页面加载速度
2. 增加图片信息重复度，提高压缩比，减少图片大小
3. 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 





# 常见面试题
重点列出，尽量全面。

## 一万条数据，怎么处理
1. 文档碎片
遍历数据，把对应的数据和结构都添加到文档碎片中，再把文档碎片插入到页面中（优势：减少DOM的回流=>基于字符串拼接也可以）
2. 虚拟DOM：类似于react框架，基于虚拟DOM以及DIFF算法，也可以优化数据绑定
以上两种方案，
->从服务器获取1万条消耗很多时间
->页面渲染1万条也消耗很多时间

3. 异步数据加载：分页加载
需要服务器端提供支持：
- 客户端向服务器端发送一个get请求，传递给服务器：每页展示的条数，当前要展示的页数等信息，例如传递的是?limit=20&page=1（每页展示20条，当前展示第一页）
- 服务器端接收到请求后，在所有的数据中把第一页的20条数据返回给客户端
- 当用户下拉加载更多或点击第二页等页码按钮时，重复第一步，把对应要展示的页码传递给服务器，服务器返回对应页码中的数据。

## 介绍一下 window.requestAnimationFrame（简称 RAF、体验优化）
实现动画流畅，更新频率需要 60 帧/s，即 16.67ms 更新一次视图
- setTimeout 要手动控制频率，而 RAF 浏览器会自动控制
- 后台标签或隐藏 iframe 中，RAF 会暂停，而 setTimeout 依然执行

`见demo`
