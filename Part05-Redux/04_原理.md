目录

[TOC]

## connect
怎么把redux中的数据挂载到当前组件中？


// React Redux 的 `connect` 函数
```js
const ConnectedComment = connect(commentSelector, commentActions)(CommentList);
```
刚刚发生了什么？！

```js
// 分开 
// connect 是一个函数，它的返回值为另外一个函数。
const enhance = connect(commentListSelector, commentListActions);
// 返回值为 HOC，它会返回已经连接 Redux store 的组件
const ConnectedComment = enhance(CommentList);
```
`connect 是一个返回高阶组件的高阶函数！`

```js
// ... 你可以编写组合工具函数
// compose(f, g, h) 等同于 (...args) => f(g(h(...args)))
const enhance = compose(
  // 这些都是单参数的 HOC
  withRouter,
  connect(commentSelector)
)
const EnhancedComponent = enhance(WrappedComponent)
```

## react-redux的原理

- connect
```js
/*
* connect(commentSelector, commentActions)(WrappedComponent)
*
* connect：高阶组件（基于高阶函数：柯里化函数）创建的组件就是高阶组件
*   @params：
*   mapStateToProps：回调函数中的部分状态信息（方法返回的内容）挂载到指定组件的属性上
*   ```
*   function mapStateToProps(state){//state：redux中的状态信息
*       return {};//=>return对象中有啥，就把啥挂载到属性上
*   }
*   ```
*   mapDispatchToProps：回调函数，把一些需要派发的任务方法也挂载到组件的属性上
*   ```
*   function mapDispatchToProps(dispatch){//dispatch：store中的dispatch
*       return {
*           init(){
*               dispatch({...});
*           }
*       };//=>return对象中有啥，就把啥挂载到属性上
*   }
*   ```
* @return：返回一个新的函数connectHOT
*
* ---------------------------------------------------------------
* connectHOT 执行
* @params：传递进来要操作的组件，需要把指定的属性和方法都挂载到当前组件的属性上
* @return：返回一个新的组件 Proxy（代理组件），在代理组件中，我们要获取 Provider 在上下文中存储的 store，紧接着获取 store 中的 state 和dispatch，把 mapStateToProps 和 mapDispatchToProps 回调函数执行，接收返回的结果，再把这些结果挂载到 Component 这个要操作组件的属性上
*
* */
function connect(mapStateToProps, mapDispatchToProps) {
    return function connectHOT(Component) {
        return class Proxy extends React.Component {
            //=>获取上下文中的 store
            static contextTypes = {
                store: PropsTypes.object
            };

            //=>获取 store 中的 state/dispatch，把传递的回调函数执行，接收返回的结果
            constructor(props, context) {
                super(props, context);
                this.state = this.queryMountProps();
            }

            //=>基于 redux 中的 subscribe 向事件池中追加一个方法，当容器中的状态改变，我们需要重新获取最新的状态信息，并且重新把 Component 渲染，把最新的状态信息通过属性传递给 Component
            componentDidMount() {
                this.context.store.subscribe(() => {
                    this.setState(this.queryMountProps());
                });
            }

            //=>渲染 component 组件，并且把获取的信息（状态、方法）挂载到组件的属性上
            render() {
                //=>渲染 COMPONENT 组件，并且把获取的信息（状态、方法）挂载到组件属性上（单独调取 POXY 组件的是时候传递的属性也给 COMPONENT）
                return <Component {...this.state}{...this.props}/>
            }

            //=>从 redux 中获取最新的信息，基于回调函数筛选，返回的是需要挂载到组件属性上的信息
            queryMountProps = () => {
                let { store } = this.context,
                    state = store.getState();
                let propsState = typeof mapStateToProps === 'function' ? mapStateToProps(state) : {};
                let propsDispatch = typeof mapDispatchToProps === 'function' ? mapDispatchToProps(store.dispatch) : {};
                return {
                    ...propsState,
                    ...propsDispatch
                };
            }
        }
    }
}

```

## redux原理
- createStore
```javascript
/**
 * @params ;reducer函数
 * @return
 *   store：{
 *      getState,
 *      dispatch,
 *      subscribe
 *  }
 */
function createStore(reducer) {
    //=>创建一个store：state用来存储管理的状态信息，listenAay用来存储时间池中的方法
    /*
    * state不用设置初始值：因为第一次dispatch执行reducer，state没有值，走的是reducer中赋值的默认值，自己在创建容器时就把dispatch执行一次
    * 只有执行subcribe，listenAry才有方法
    *
    * */
    let state,
        listenAry = [];

    //=>dispatch：基于dispatch实现任务派发
    function dispatch(action) {
        //=>1.执行reducer，修改容器中的状态信息（接收reducer的返回值，把返回的信息替换原有的state），需要注意的是，我们是把返回值全部替换state，所有要求reducer中在修改状态之前，要先把原始状态信息克隆一份，再进行单个的属性修改
        state = reducer(state, action);
        //=>2.容器中状态信息经过修改之后，通知事件池中的方法执行
        for (let i = 0; i < listenAry.length; i++) {
            let item = listenAry[i];
            if (typeof item === 'function') {
                item();
            } else {
                listenAry.splice(i, 1);
                i--;
            }
        }
    }

    //=>getState：获取状态中的信息
    function getState() {
        //=>1.需要保证返回的状态信息不能和容器中的state是同一个堆内存（否则外面获取状态信息后直接就可以修改，这不符合dispatch->reducer修改状态的流程）
        //{...state}浅克隆
        return JSON.parse(JSON.stringify(state));//=>深度克隆
    }

    //=>subscribe：向事件池中追加方法
    function subscribe(fn) {
        //=>1.向事件池中追加方法
        let isExit = listenAry.includes(fn);//=>重复验证
        !isExit ? listenAry.push(fn) : null;
        //=>2.返回一个方法：执行返回的方法，会把当前绑定的方法，从事件池移除
        return function unsubscribe() {
            let index = listenAry.indexOf(fn);
            // listenAry.splice(index, 1);//=>可能会引发数组塌陷
            listenAry[index] = null;
        }

    }

    dispatch({type: '$$INIT_DEFAULT_STATE'});//=>创建容器时，执行一次dispatch，目的是把reducer中的默认状态值赋值给redux容器中的状态

    return {
        getState,
        dispatch,
        subscribe
    };
}

//=>用法
let reducer = (state = {}, action) => {
    //=>state：原有状态信息
    //=>action：派发任务时传递的行为对象
    switch (action.type) {
        //=>根据type执行不同的state修改操作
        case TYPE.XXX:
            state = {...state, n: state.n + 1}
    }
    return state;//=>返回的state会替换原有的state
};
let store = createStore(reducer);//=>create时，把reducer传递进来，但是此时reducer并没有执行，只有dispatch时才执行，通过执行reducer修改容器中的状态
//store.dispatch({type:'xxx'});
```
- combineReducers
```js
/*
* 合并reducer的方法
*   @params：对象，对象中包含了每一个板块对象的reducer => {xxx: function reducer ...}
*   @return：返回的是一个新的reducer函数（把这个值赋值给createStore）
* 特殊处理：合并reducer之后，redux容器中的state也变为以对应对象管理的模式 => {xxx: function reducer ...}
* */
function combineReducers(reducers) {
    //=>reducers：传递进来的reducer对象集合
    /*
     * {
     *    vote:function vote(state={n:0,m:0},action){... return state;},
     *    personal:function personal(state={baseInfo:''},action){... return state;}
     *    ...
     * }
     */
    return function reducer(state = {}, action) {
        //=>dispatch派发执行时，执行的是返回的reducer，这里也要返回一个最终的state对象，替换原有的state，而且这个state中需要包含每个模块的状态信息 =>{vote:...,personal:...}
        //=>reducer合并：其实就是dispatch派发时，把每一个模块的reducer都单独执行一遍，把每一个模块返回的状态最后汇总在一起，替换容器中的状态信息
        let newState = {};
        for (let key in reducers) {
            if (!reducers.hasOwnProperty(key)) break;
            //=>reducers[key]：每个模块对应的reducer
            //=>state[key]：当前模块在redux容器中存储的状态信息
            newState[key] = reducers[key](state[key], action);
        }
        return newState;
    }
}

```
