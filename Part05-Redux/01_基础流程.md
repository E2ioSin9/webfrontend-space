目录

[TOC]


# 基本概念
> Redux 是 JS 的一个 全局状态管理容器。

作用:
**临时存储**，页面一旦刷新，所有组件和程序重新运行，之前存储的redux 数据会恢复默认值。

三大原则：
- 单一数据源：整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中
- State 是只读的：唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象
- 使用纯函数来执行修改：Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state




Redux 提供了以下 API：
```js
export {
  createStore,
  combineReducers, // 合并多个 reducer
  bindActionCreators,
  applyMiddleware,
  compose,
  __DO_NOT_USE__ActionTypes
}
```

栗子：
- [redux-counter-base](https://codesandbox.io/s/redux-counter-base-kzvd2)
- [redux-counter-dump-reset](https://codesandbox.io/s/redux-counter-dump-reset-p51sp)


# Store
> **Redux 只有一个单一的 store。**

createStore() 用于创建一个存储状态的容器（store 对象）：需要把合并后的 reducer 传递进来
```js
import { createStore } from 'redux';

const store = createStore(reducer);
```
源码：
```js
createStore(reducer, preloadedState, enhancer) {
	return {
    dispatch, // 派发一个 action（传递一个`对象`，type 属性），更新 state
    subscribe, // 事件池追加方法
    getState, // 获取 state
    replaceReducer,
    [$$observable]: observable
  }
}
```

# Action
1. 本质
> Action 本质上是一个 JavaScript 普通对象。


一般来说，你会通过 store.dispatch() 将 action 传到 store。
```js
store.dispatch({ type: "INCREMENT" }); // action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作
store.dispatch({ type: "DECREMENT" });
```

2. Action 创建函数
区别“action” 和 “action 创建函数” 这两个概念。
在 Redux 中的 action 创建函数（也称为 Action creator，动作生成器）只是简单的返回一个 action:
```js
const addTodo = (text) => {
  return {
    type: ADD_TODO,
    text, // text 是传过去的参数，这个传参就会用于组成 Action 对象中的 payload
  }
}
```


# Reducer
> **reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。**
=> 作用：将 action 和 state 串起来，根据 action 的不同 type 走不同的修改任务

[参数]
- state：容器中原有的状态信息（initialState 为初始默认值）
- action：dispatch 任务派发时传递的行为对象
```js
const initialState = {
  n: 0
};

export default (state = initialState, action) => {
  switch (action.type) {
    // case 'dump':
    //   return {
    //     ...state,
    //     ...action.payload,
    //   };
    // case 'reset':
    //   return {
    //     ...state,
    //     ...initialState,
    //   };
    case "INCREMENT":
      return {
        ...state,
        n: state.n + 1
      };
    case "DECREMENT":
      return {
        ...state,
        n: state.n - 1
      };
    default:
      return state;
  }
};
```
永远不要在 reducer 里做这些操作：
- 修改传入参数
- 执行有副作用的操作，如 API 请求和路由跳转
- 调用非纯函数，如 Date.now() 或 Math.random()


注意：
> **Redux 只有一个根级的 reducer 函数**，把根级的 reducer 拆成多个小的 reducers，再使用 combineReducers() 将多个 reducer 合并成为一个。

```js
import { combineReducers } from 'redux';

const reducer = combineReducers({
  reducerA,
  reducerB,
})

export default reducer;
```
保证合并每个模块管理的状态信息不会相互冲突：
等价于：
```js
function reducer(state = {}, action) {
  return {
    reducerA: reducerA(state.reducerA, action),
    reducerB: reducerB(state.reducerB, action)
  }
}

export default reducer;
```


# 单项数据流模型
1. store.dispatch(action)
2. reducer -> newState
3. store.subscribe(listener) 订阅更新

Redux store 保存了根 reducer 返回的完整 state 树。
这个新的树就是应用的下一个 state！所有订阅 store.subscribe(listener) 的监听器都将被调用；监听器里可以调用 store.getState() 获得当前 state。






# 面试高频题目
1. 描述 redux 的单项数据流模型 *


