目录

[TOC]

# 什么是高阶组件？
> 高阶组件（HOC）是 React 中`用于复用组件逻辑`的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的`设计模式`。

具体而言，**高阶组件就是一个函数，且该函数接收一个组件作为参数，并返回一个新的组件**。

HOC 在 React 的第三方库中很常见，例如 Redux 的 connect。HOC 是纯函数，没有副作用。

```js
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```
higherOrderComponent 的最简实现：
```js
function withXXX(WrappedComponent) {
    return class extends React.Component { // 可以匿名，可以具名 Enhancer
        render() {
            return <WrappedComponent {...this.props} />
        }
    }
}
```
结合其它库的实现：
1. ES7 的 Decorators
```js
import { withProps } from 'recompose';
//...
const withQuery = withProps((ownerProps) => {
  const { page, size } = ownerProps;

  return {
    query: {
      page,
      size,
    },
  };
});

@connect(mapStateToProps, mapDispatchToProps)
@withQuery
class WrappedComponent extends Component { }
```

2. compose
```js
import { compose } from 'recompose';
//...
const withHoc = compose(withA, withB, withC)

@withHoc
class WrappedComponent extends Component { }
```


# 实现方式
参考出处：
- [React组件复用指南](https://github.com/Advanced-Interview-Question/front-end-interview/blob/master/docs/guide/abstract.md)
- [【React深入】从Mixin到HOC再到Hook](https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-0)

## 属性代理(Props Proxy)
在 render 中返回要包裹的组件，这样我们就可以代理所有传入的 props，并且决定如何渲染。
1. 操作 props
可以对传入组件的 props 进行增加、修改、删除，或者根据特定的 props 进行特殊的操作。

```js
function proxyHOC(WrappedComponent) {
  return class extends React.Component {
    render() {
      const newProps = {
        user: 'ConardLi'
      }
      return <WrappedComponent {...this.props} {...newProps} />;
    }
  }
}
```
2. 包裹样式（复用样式、布局）
```js
function styleHOC(WrappedComponent) {
  return class extends React.Component {
    render() {
      return (
        <div style={{display: 'block'}}>
          <WrappedComponent {...this.props}/>
        </div>
      )
    }
  }
}
```


## 反向继承(Inheritance Inversion)

```js
function inheritHOC(WrappedComponent) {
  return class Enhancer extends WrappedComponent {
    render() {
      return super.render()
    }
  }
}
```
可以看到，返回的组件（Enhancer）继承了 WrappedComponent，它们的关系看上去被`反转(inverse)`了。

由于继承了原组件，能通过 this 访问到 WrappedComponent 的生命周期、props、state、render等，相比属性代理它能操作更多的属性。


你可以用 Inheritance Inversion 做什么？
- 渲染劫持（Render Highjacking）
- 操作 state


### 渲染劫持

之所以被称为渲染劫持是因为 `HOC 控制着 WrappedComponent 的渲染输出`，通过渲染劫持你可以：
- 修改由 super.render() 方法输出的 React 组件树

1. 条件渲染
```js
function visibleHOC(WrappedComponent) {
  return class extends WrappedComponent {
    render() {
      if (this.props.visible === false) {
        return null
      } else {
        return super.render()
      }
    }
  }
}
```

2. 包裹样式
```js
function styleHOC(WrappedComponent) {
  return class extends WrappedComponent {
    render() {
      return (
        <div style={{display: 'block'}}>
          <div className="title">{this.props.title}</div>
          {super.render()}
        </div>
      )
    }
  }
}
```

注：在 Props Proxy 中不能做到渲染劫持。 虽然通过 WrappedComponent.prototype.render 你可以访问到 render 方法，不过还需要模拟 WrappedComponent 的实例和它的 props，还可能亲自处理组件的生命周期，而不是交给 React。


# 注意
1. 不要改变原始组件 WrappedComponent

2. 不要在 render 方法中使用 HOC
```js
render() {
  // 每次调用 render 函数都会创建一个新的 EnhancedComponent
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！
  return <EnhancedComponent />;
}
```
React 的 diff 算法（称为协调）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。

3. 务必复制静态方法
```js
// 定义静态函数
WrappedComponent.staticMethod = function() {/*...*/}
// 现在使用 HOC
const EnhancedComponent = enhance(WrappedComponent);

// 增强组件没有 staticMethod
typeof EnhancedComponent.staticMethod === 'undefined' // true
```

```js
import hoistNonReactStatic from 'hoist-non-react-statics';
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // 1. 手动复制
  Enhance.staticMethod = WrappedComponent.staticMethod;
  // 2. 使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:
  hoistNonReactStatic(Enhance, WrappedComponent);
  return Enhance;
}
```
4. Refs 不会被传递


# 面试高频题目
1. 什么是高阶组件？在项目中一般怎么使用？