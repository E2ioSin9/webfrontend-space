目录

[TOC]

# 顺序执行？
通常我们会将 JavaScript 归类为“直型译”或“解释执行”语言，会认为代码在执行时是由上到下按顺序执行的，但是：
```js
console.log(a);
var a = 12;
```
输出的是 undefined，而不是报 ReferenceError 错误（变量未声明）！

那么到底发生了什么？

我们都知道，是**提升（hoisting）**，那么，JS 引擎究竟是如何处理这段代码的呢？

> 在《你不知道的JavaScript》中，有这样一句话：
> 任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前的几微妙，甚至更短！）。

事实上，***JavaScript 是一门编译语言***。引擎会在执行代码之前首先对其进行编译。


# JavaScript 引擎执行过程
为了更好的理解编译，我们先了解一下 JS 引擎的执行过程：
1. JS 引擎在执行代码时，会按顺序加载由 script 标签分割的 JS 代码块。
2. 当一个 JS 代码块加载完毕后，会按照以下 **三个阶段** 进行处理：
    - 语法分析阶段
    - 预编译阶段
    - 执行阶段
  首先会在代码块整个范围内进行语法分析。语法错误，会抛出一个**语法错误（SyntaxError）**。语法无误，然后就会“**一段一段**“的对代码进行编译和执行。
4. 当前代码块执行完毕，然后再按顺序查找下一个代码块。
5. 每一个代码块，都重复以上 3 个阶段的执行。


这个“**一段一段**”中的“段”究竟是怎么划分的呢？

这就要说到 JS 执行环境了，就三种：
- 全局环境
- 函数环境
- eval 函数环境 （已不推荐使用）

很好理解，开始执行代码时，首先进入的是全局环境，遇到函数就进入函数环境。
其实，**每进入一个环境，JS 引擎都要进行编译和代码执行**。

# JavaScript 是一门编译语言
在预编译阶段，JS 引擎会为当前环境做一些**准备工作**，比如创建变量对象、确定作用域等。

这里先插播一个知识点：这个准备工作，就是**执行上下文**（**Execution context**）啦！

先简单了解下，执行上下文在创建阶段，会创建一个变量对象（包含变量、函数的声明），在执行阶段，会完成变量的赋值（修改变量对象的值）。

我们再来看上边的这段代码：
```js
console.log(a);
var a = 12;
```

JS 引擎是这样处理的：

1. 首先进行全局环境，对代码进行编译，会创建**全局执行上下文（Global Execution Context）**。
    ```js
    globalContext = {
        VO: [global], // VO - 变量对象
        ...
    }
    ```

2. globalContext 初始化时，完成变量的声明，执行 var a
    ```js
    global = {
        a: undefined,
    }
    ```
3. 编译结束后，自上到下执行全局代码，执行 console.log(a) 输出 undefined，执行 a = 12，引擎首先会在当前执行环境中，寻找变量 a，这个变量存在，对它赋值。
    ```js
    global = {
        a: 12,
    }
    ```
其实，赋值操作就是修改的全局对象 VO 的属性 a 的值。


我们可以看到，var a = 2; 这样的声明会被分解成了两个独立的步骤：
1. var a，变量的声明，是在**预编译阶段**处理的。
2. a = 12，变量的赋值，是在**执行阶段**完成的。

而经过 JS 引擎编译后直译的代码是：
```js
var a ;
console.log(a);
a = 12;
```
这也就是变量出现提升的原因了。


# 常见面试题（无）
