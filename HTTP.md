目录

[TOC]

# 客户端和服务端的交互模型
1. 客户端
2. DNS 解析服务器：记录所有的域名解析记录。访问域名时，对域名进行DNS解析：找到`对应的服务器外网IP`。
DNS（Domain Name System，域名系统），万维网上作为域名和服务器 IP 地址相互映射的一个分布式数据库。

3. 服务器端
- 服务器上是不允许安装除了开发需要的环境项以外的任何东西，因为服务器上安装一款应用都可能会作为一个服务，占用一个端口
- 开发者基于`FTP`把项目源文件上传到服务器指定的磁盘。
- 服务器上的项目是`基于端口号`区分的，不同的端口号管控不同的项目。
- 给服务器联网后，服务器会有一个自己的外网IP（一般都会禁止通过外网IP访问网站）

4. 发布WEB站的部署工具：IIS（C#...Windows）、APACHE TOMCOT（PHP/JAVA...->Linux）、NGINX。
指定当前域名访问服务器后，执行的是哪一个项目的源代码关联。

> 面试题：打开一个浏览器，在地址栏输入一个URL，按下enter键，到看到整个页面。中间都经历了哪些步骤？

1. HTTP请求阶段
向服务器发送请求
- 浏览器首先向DNS解析服务器发送一个请求
- DNS反解析：根据浏览器URL中的`域名`，找到`对应的服务器外网IP`
- 通过找到的外网IP，向对应的服务器发送请求
- 通过URL中的`端口号`，匹配出请求的时服务器上哪个服务（项目），以及服务所管理的项目源文件
2. HTTP响应阶段
服务器把浏览器需要的内容准备好，响应给客户端
- 服务器端根据URL中的路径名称、问号传参或者哈希值，把客户端需要的内容进行准备和处理
- 把准备内容响应给客户端（如果请求的是HTML或CSS等这样的资源文件，服务器返回的是资源文件中的`源代码`[不是文件本身]，`音视频、图片除外`）
3. 浏览器渲染阶段
客户端浏览器接收到服务器返回的源代码，基于自己内部的渲染引擎（内核）开始进行页面的绘制和渲染
	+ 首先计算DOM结构，生成DOM Tree
	+ 自上而下运行代码，加载CSS等资源内容
	+ 根据获取的CSS生成带有样式的：Render Tree
	+ 开始渲染（绘制）页面


注意：遇到link、script，只要文件不在当前返回的页面中，就会再次向服务器发送一次请求，每一次请求都会重头开始走1,2,3的所有步骤。

# 一个完整的URL的组成
> URI = URL + URN
> URI：Identifier，统一资源标志符
> URN：Name，统一资源命名。即通过名字来标识资源的。
> **URL：Uniform Resource Locator，统一资源定位符**。即 URL 可以用来标识一个资源，而且还指明了如何定位这个资源。

一个完整的 URL 包含协议名称，主机名称（IP 或者域名）、端口号（没写端口号默认为 80 端口）、路径和查询字符串这5个部分。

1. 【传输协议】
常用的有
- `HTTP`：Hyper Text Transfer Protocol，超文本传输协议（除了传递普通的文本，还可以传递文件流或者进制编码等信息）（目前最常用）
- `HTTPS`：基于`SSL`（Secure Socket Layer，安全套接层）加密的HTTP传输协议，比HTTP更安全（涉及支付的网站一般是基于HTTPS完成的）
- `FTP`：File Transfer Protocol，文件传输协议，一般用来实现资源文件在服务器上的上传下载，相对于HTTP/HTTPS，FTP 传的文件大

2. 【域名】Domain Name
- 一级域名（顶级域名）www.qq.com
- 二级域名  news.qq.com
- 三级域名
.com：供商用的国际域名
.cn：供商用的中文域名
.net：用于网络供应服务商（系统类的）
.org：用于官方组织
.edu：供教育机构使用
.gov：用于政府机构
.vip

3. 【端口号】
用于区分同一台服务器上不同服务的标识（基于WEB服务管理创建服务时可以指定），不同服务之间一般不能使用相同的端口号。
- 一台服务器上的默认端口号范围：0~65535
- 默认值：HTTP 默认 80、HTTPS 默认 443、FTP 默认 21

注意以下几点：
1）默认端口管理是`浏览器行为`，当用户输入网址不写端口号时，浏览器会自动把默认的端口传递给服务器。

4. 【请求路径名称】
path
pathname
例如：/stu/index.html一般都是请求当前服务器对应的项目目录中，stu文件夹中的index.html页面。
特殊情况：当前的URL是被`伪URL重写的`（发生在前后端未分离的情况下），看到的URL请求其实不是真实的请求。

DHTML：动态页面，泛指当前页面中的内容不是写死的而是动态绑定的，例如，.jsp/.php/.aspx...这些页面中的数据都是基于Ajax或者后台编程语言处理，由服务器端渲染，最终把渲染后的结果返回给客户端呈现。

//=>例如，https://item.jd.com/4082786.html它的真实URL地址很可能是https://item.jd.com/detail.jsp?id=4082786

详情页模型：`同一个详情页，通过问号传参的方式，传入不同的产品ID，来展示不同的产品信息。`
但，像detail.jsp这种服务器渲染的动态页面不能被搜索引擎收录，不利于页面的SEO。

像：`/stu/info` 这种没有任何后缀信息，一般都不是用来请求资源文件的，而是用于`AJAX数据请求的接口地址`（如果后缀是.json类的，也是同理），但是有一种除外` /stu/info/` 这种的很可能不是接口地址，而是没有指定请求的资源名称，服务器会`请求默认的资源文件`，一般都是index.html/default.html...

5. 【问号传参及哈希值】
在HTTP事务中，问号传参是客户端把信息传递给服务器的一种方式。（也有可能是跳转到某一个页面，把参数值传递给页面用来标识的）
哈希值主要用于页面中的锚点定位和 HASH 路由切换。


# HTTP
## HTTP事务
1. 一次完整的`请求 + 响应`称之为 HTTP 事务。事务是完整的一次操作，请求和响应缺一不可。


2. 一个页面完全加载完，需要向服务器发起很多次 HTTP 事务操作。
	+ 一般来说，首先把HTML源代码拿回来，加载HTML时，遇到`link` / `script` / `img[src]` / `frame` / `video`和`audio（没有设置preload='none'）`...都会重新和服务器端建立HTTP事务交互。
	+ 特殊情况：如果做了资源缓存处理（304），而且即将加载的资源在之前已经加载过了，这样的操作和传统的HTTP事务不一样，它们是从服务器和浏览器的缓存中读取数据。




## HTTP报文
在客户端向服务器发送请求，以及服务器把内容响应给客户端时，中间相互传递了很多内容（客户端把一些内容传递给服务器，服务器把一些内容响应给客户端），我们把传递的内容统称为“HTTP 报文”。

1. 起始行：
- 请求起始行：method  HTTP协议
- 响应起始行：HTTP协议  status   statusText
2. 首部（头）：
- 通用头
```
//=>General
Request URL: https://www.baidu.com/
Request Method: GET
Status Code: 200 OK
Remote Address: 61.135.169.121:443 //=>主机地址（服务器外网IP地址）
Referrer Policy: no-referrer-when-downgrade //=>指定请求是从哪个页面跳转来的，分析用户来源
```
- 响应头（Response Headers）
服务器端设置
	+ `Date`：服务器响应内容的`服务器端时间`，和客户端拿到响应内容的真实时间有误差，因为返回到客户端需要时间
		+ GMT是格林尼治时间，比北京时间慢8个小时，北京时间是GMT+0800
```javascript
HTTP/1.1 200 OK //=>响应起始行，304表示是从上次缓存直接拿的，if-Modified-Since是记录上一次缓存时间
Bdpagetype: 2
Bdqid: 0xdf36fb1600050d34
Cache-Control: private
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Sun, 27 May 2018 01:13:00 GMT //=>服务器端时间，GMT是格林尼治时间
Expires: Sun, 27 May 2018 01:12:59 GMT
Server: BWS/1.1  //=>管理web服务的工具
Set-Cookie: BDSVRTM=328; path=/
Set-Cookie: BD_HOME=1; path=/
Set-Cookie: H_PS_PSSID=18195_1460_21092_26350_26432; path=/; domain=.baidu.com
Strict-Transport-Security: max-age=172800
X-Ua-Compatible: IE=Edge,chrome=1
Transfer-Encoding: chunked
```
- 请求头（Request Headers
```javascript
GET / HTTP/1.1 //=>请求起始行
Host: www.baidu.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.170 Safari/537.36  //=>记录浏览器版本信息
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: ...//=>cookie信息一般都是放到头文件中实现和服务器端的数据通信的
```

3. 主体：
- 请求主体（`Request Payload / Form Data`）
客户端传递给服务器的内容
表单验证时
- 响应主体（Response）
服务器返回的是啥就是啥

## HTTP请求方式
所有的请求都可以给服务器端传递内容，也都可以从服务器端获取内容
1. GET 系列
  - `get`：从服务器端获取数据（给的少拿的多）
  - `delete`：删除服务器端的某些内容（一般是删除一些文件）
  - `head`：只想获取服务器返回的响应头信息，不要响应主体中的内容
  类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。
  - `options`：一般向服务器发送一个探测性请求，如果服务器端返回信息了，说明当前客户端和服务器端建立了连接，可以继续执行其它请求了（trace更适合）
  但是`axios`这个Ajax类库在基于cross domain进行跨域请求时，就是先发送options请求进行探测尝试，如果能联通服务器，才会继续发送其它请求。
  - `trace`：主要用于测试和诊断
  - `connect`

2. POST 系列
  - `post`：向服务器端推送数据（给的多拿的少）
  - `put`：向服务器上存放一些内容（一般是存放文件）`更新`


## HTTP网络状态码（status）
1. 分类：1-指示  2-成功  3-重定向  4-客户端错误   5-服务器错误
2. 常见的HTTP状态码：
  - `200` - 请求成功（只能证明成功返回了，但是信息不一定是业务需要的）
  - `301` - 资源被永久转移到其它URL
    =>域名更改，访问原始域名重定向到新的域名
  - `302` - 资源被临时转移到其它URL（临时重定向=>`307`）
    =>`307`：网站有的是基于HTTPS协议运作的，如果访问的是HTTP协议，会基于307重定向到HTTPS协议上
    =>302一般用作服务器的负载均衡，当一台服务器达到最大并发数（同时处理用户的能力）时，会把后续访问的用户临时转移到其它的服务器机组上处理。例如，项目中会把所有图品放到单独的“图片处理服务器”上
  - `304` - 该资源在上次请求之后没有任何修改，可直接使用浏览器中的缓存版本
    对于不经常更新的资源文件，例如：css、js、HTML、IMG等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端，下次再获取时，是从缓存中获取；如果资源更新，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取；基于Ctrl+F5强制刷新页面，304缓存就没用了。
  - `400` - Bad Request 请求参数错误
  - `401` - Unauthorized 无权限访问
  - `404` - Not Found 请求的资源不存在（地址不对）
  - `403` - 请求的资源访问被禁止
  - `413` - Request Entity Too large 和服务器交互的内容资源超过服务器最大限制
  - `500` - Internal Server Error 未知服务器错误
  - `503` - Service Unavailable 服务器超负荷


客户端和服务器端信息交互的方式
【客户端传递给服务器】
- 问号传参
请求的URL地址末尾通过问号传参方式，把一些信息传递给服务器，例如，/info?limit=10&page=1
- 设置请求头
客户端把需要传递给服务器的内容设置到请求头信息中（自定义请求头），服务器可以通过接收请求头信息把内容得到
- 设置请求主体
xhr.send([请求主体内容]);
Ajax的send中传递的内容，就是客户端设置的请求主体内容，服务器端可以接收到这些信息的。
注意：请求头信息会优先请求主体优先达到服务器，但设置请求头的方法并不常用。

【服务器返回给客户端】
- 设置响应头信息
例如，把服务时间通过响应头返回给客户端，客户端通过获取响应头信息得到这个时间（响应头返回的速度是优先于响应主体的）
- 设置响应主体
主要的返回信息都在响应主体中




# 常见面试题
## 输入一个URL
面试题：打开一个浏览器，在地址栏输入一个URL，按下enter键，到看到整个页面。中间都经历了哪些步骤？

==二次握手、三次挥手==

## GET 与 POST 的区别
- 第一，传递给服务器信息的方式不一样
GET 基于`URL地址问号传参`、POST 基于`请求主体`
```javascript
//=>GET
xhr.open("GET","/temp/接口?xxx=xx&xx=xx")
//=>POST
xhr.send("xxx=xx&xx=xx");
```

- 第二，GET 不安全，POST 相对安全
GET 基于问号传参把信息传递给服务器的，容易被骇客进行 URL 劫持，POST是基于请求主体传递的，相对来说不好被劫持。
=>所以登录、注册等涉及安全性的交互操作，一般用 POST 请求。

- 第三，GET通过 URL 传递参数有长度限制，POST 没有限制。
`浏览器对于URL的长度有最大限制`（谷歌8KB、火狐7KB、IE2KB...），GET 请求基于问号传参，拼接URL不要过长，超出部分会被浏览器截断，POST 请求基于主体传递，没有限制。
=> 向服务器发送数据较大用 POST

- 第四，GET 会产生不可控制的缓存，POST 不会
GET请求产生缓存是因为连续多次向相同的地址（并且传递的参数信息也是相同的）发送请求，浏览器会把之前获取的数据从缓存中拿到返回，导致无法获取服务器最新的数据（POST不会）
=>解决：控制缓存的产生，而不是产生了再干掉
```javascript
xhr.open('GET',`/temp/list?lx=1000&_=${Math.random()}`);//=>每一次请求的末尾追加一个随机数，保证每一次请求的地址不完全一致（使用_作为属性名是不想和其它的属性名冲突）
```

- 第五，GET 后退/前进不会重复提交，POST 会重复提交。


## HTTP协议的主要特点
HTTP 协议基于客户端/服务端（C/S）的架构模型。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即WEB服务器发送所有请求。主要特点有：
- 简单快速
HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。
每一个URI都是固定的，即统一资源符。要访问这个资源只要输入一个URI。
- 灵活
通过一个 HTTP 协议可以完成不同数据类型的传输。
- `无连接`
限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
- `无状态`
指协议对于事务处理没有记忆能力。就是对于每次连接并不会保存状态。

## Keep-Alive模式（持久连接）
前提：HTTP1.1版本支持，1.0不支持。
HTTP协议采用“请求-应答”模式。
当我们使用普通模式时，HTTP协议为无连接协议。每一次的请求-应答客户端和服务器都要新建一个连接。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
当我们使用Keep-Alive模式，Keep-Alive使得客户端到服务器端的连接持续有效，当再次对服务器发送请求时，Keep-Alive避免了重新建立连接。

## 管线化
![](http://upload-images.jianshu.io/upload_images/8059334-505ab02364c90cf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
工作原理：
前提是：在持久连接的情况下完成
持久连接一般是请求一次响应一次，整个连接不中断。管线化是把现在的所有请求打包一次传输过去，服务器也打包一次性的响应回来。

特点：说出前3点就可以
![](http://upload-images.jianshu.io/upload_images/8059334-79298364963ff9fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## HTTP的报文组成，请求方式，状态码
