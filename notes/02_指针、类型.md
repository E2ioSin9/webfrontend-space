# 指针
指针是可见的内存地址，& 操作符可以返回一个变量的内存地址，并且 * 操作符可以获取指针指向的变量的值，但是在 Go 语言里没有指针运算。

## &、*
对于任何一个变量 a，如下表达式都是正确的：a == *(&a)。

1. &: 获取变量的内存地址

2. \*
    - 声明指针变量
    > 语法： var var_name *var-type

    ```go
    package main

    import "fmt"

    func main() {
        var a int = 10   
        var b *int
        b = &a;
        
        fmt.Printf("变量的地址: %x\n", b) // %x 表示16进制地址
    }
    // 变量的地址: 414020
    ```

- 获取、操作指针变量的值
    ```go
    package main  
    import (  
        "fmt"
    )

    func main() {  
        b := 255
        a := &b
        fmt.Println(a)
        fmt.Println(*a)
        *a++
        fmt.Println(b) // *b 报错，invalid indirect of b (type int)  思考: 为什么？
        *a = 1
        fmt.Println(b, a, *a)
    }
    // 0x414020
    // 255
    // 256
    // 1 0x414020 1
    ```
    > b 是一个 int 类型的变量，并不是一个指针变量，因此不能通过 * 来访问。

    这里是区别于 JS 的，JS 基本类型的值是互不影响的（传递的是一个副本，对应不同的栈内存地址），而 `Go 只要通过 & 将一个变量的内存地址赋给另一个变量，两者就指向同一块内存空间，通过 * 来修改值修改的是两者的值`。

## 空指针
nil 类似于 JS 中的 null。

一个指针已声明而没有赋值时，称为空指针，为 nil 。任何类型的空指针都是 nil。

一个指针变量通常缩写为 ptr。
```go
if(ptr != nil)     /* ptr 不是空指针 */
if(ptr == nil)    /* ptr 是空指针 */
```

## 判断指针是否相等
```go
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
```

在函数内部声明的指针，每一次调用函数，返回的地址是不同的
```go
// ...
func main() {
	fmt.Println(f() == f())
}

func f() *int {
	v := 1
	return &v
}
// "false"
```

## 指针传递
一个指针作为函数的参数传递进去，在函数中，可以通过指针来操作变量的值

```go
package main

import "fmt"

func main() {
	v := 1
	incr(&v)              // side effect: v is now 2
	fmt.Println(incr(&v), v) // "3" (and v is 3)
}

func incr(p *int) int {
	*p++
	return *p
}
```


# new函数 -> 创建匿名的指针变量
> new(T) 将分配一片内存，创建一个`T 类型的匿名变量`，返回一个`内存地址`，即一个指向类型为 T，值为 0 的指针。
它适用于`值类型`，如`数组和结构体`，相当于 &T{}。

```go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```
new 函数创建变量，是一种语法糖，因为可以直接返回一个指针变量，而不用声明一个临时的变量。
两个函数有着相同的行为：创建变量，并返回变量地址。
```go
func newInt() *int {
    return new(int)
}
// 等同于
func newInt() *int {
    var dummy int
    return &dummy
}
```

> 每次调用 new 函数都是返回一个新的变量的地址
```go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

# type
包一级
> type 类型名字 底层类型

对于每一个类型 T，都有一个对应的类型转换操作 T(x)，用于将 x 转为 T 类型。



# 深拷贝和浅拷贝
        深拷贝：拷贝的是数据
            值类型都是深拷贝，基本类型，数组

        浅拷贝：拷贝的是地址
            引用类型默认都是浅拷贝，切片，map