

面向对象：Go 仅支持封装，不支持继承和多态。没有 class，只有 struct。

GO 中没有继承，它的模拟继承的行为是通过`内嵌或组合`来实现的：

Go 不是一个面向对象的语言，但一个类型加上它的方法等价于面向对象中的一个类，语法上，类型和它的方法必须是同一个包的，它们之间的关联由接收者来建立。

## 内嵌结构体
实现 B 继承自A：结构体也是一种数据类型，因此内层结构体 A 可以作为一个`匿名字段`，直接嵌入 外层结构体 B 中，A 中的字段也都全部添加到 B 中。
将父类型放在子类型中来模拟经典面向对象语言中的继承。

```go
type A struct {
	Sex int
}
type B struct {
	A
	Name string
	Age  int
}

func main() {
	b := B{Name: "chen", Age: 29, A: A{Sex: 0}}
    fmt.Println(a)
    
	b.Age = 26
	b.Sex = 1 // b.A.Sex = 1
	fmt.Println(b)
}
// {{0} chen 29}
// {{1} chen 26}
```

当内嵌类型和外层类型的方法、属性重名时，屏蔽效果。
```go
type A struct {
	Sex int
}

func (a A) Speak()  {
	fmt.Println("I am A",a.Sex)
}

type B struct {
	A
	Name string
	Age  int
}

func (b B) Speak()  {
	fmt.Println("I am B",b.Sex)
}

func main() {
	b := B{Name: "chen", Age: 29, A: A{Sex: 0}}
	b.Speak()
	b.A.Speak()
}
// I am B 0
// I am A 0
```


# 多重继承
Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。
```go
// ...
type Camera struct{}

func (c *Camera) TakeAPicture() string {
	return "Click"
}

type Phone struct{}

func (p *Phone) Call() string {
	return "Ring Ring"
}

type CameraPhone struct {
	Camera
	Phone
}

func main() {
	cp := new(CameraPhone) // &{{} {}}
	fmt.Println(cp.TakeAPicture())
	fmt.Println(cp.Call())
}
// Click
// Ring Ring
```