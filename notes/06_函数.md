
Go 里面有三种类型的函数：
- 普通的具名函数
- 匿名函数或者lambda函数
- 方法（Methods）

不支持函数重载。

# 定义
定义格式：
```go
func function_name([parameter list]) [return_types] {
   body
}
```
- parameter list（非必需）
如果传递的参数多于3个，可以传递一个切片（返回值具有相同类型）或者是传递一个结构体（返回值具有不同的类型）。

- return_types（非必需）：`多值返回`是 GO 函数的一大特性。
    + 返回值有非命名返回值、命名返回值，当返回值是多个时，需要用()括起来。

- body
    任何一个有返回值（单个或多个）的函数都必须以 return 或 panic 结尾。

```go
// 非命名返回值语法：Type
func test(input int) (int, int) {
    return 2 * input, 3 * input
}

// 命名返回值语法：(返回值形参 Type)
func test(input int) (a int, b int) {
    a = 2 * input
    b = 3 * input
    // return x2, x3
    return
}
```

当函数被调用，返回多个值时，可以使用空白符（blank identifier）_ 占位，丢弃掉不需要的返回值。
```go
_, n1 := test(10)
```

# 函数类型
Go 语言中，函数也是一种类型。如果两个函数的入参类型和返回值类型均相同，则它们的类型相同。函数作为参数时，非常有用。

可以给某总函数类型创建类型别名，使程序更简洁。
```go
func calculate(a,b int,f func(int,int) int) (r int) {
	r = f(a,b)
	return
}
// 创建类型别名
type calculateFunc func(int,int) int
func calculate(a,b int,f calculateFunc) (r int) {
	r = f(a,b)
	return
}
```

# 匿名函数
Go 语言中，函数可以作为一个值，不可以独立存在，但可以：
1. 被赋值于某个变量，用变量名来调用
2. 自执行直接调用

```go
var add = func(a,b int) (r int) {
	r = a + b
	return
}
add(1,2)

// 等同于
sum := func(a,b int) int {
	return a + b
}(1,2)
```


# 函数传参：按值传递
基本类型传递的是一个值的副本，引用类型传递的是一个指针的副本。所以 GO 中的函数参数传递也是按照值进行传递的。

像`切片（slice）、字典（map）、接口（interface）、通道（channel）`这样的引用类型都是传递的指针的副本，即使没有显示的指出指针。
像`数组、结构体`这样的值类型，可以在实参前加 & 符号，传递的也是指针了（显示的指出指针）。

当传递给函数指针时，可以修改外部变量，不需要 return 返回，但是，这种操作要小心使用，最好添加注释。
```go
func main() {
	s := []int{1, 2, 3, 4, 5}
	fmt.Printf("%p\n", &s)
	modify(s)
	fmt.Println(s)
}

func modify(s []int) {
	fmt.Printf("%p\n", &s)
	s[1] = 10
}
// 0x40a0e0
// 0x40a0f0
// [1 10 3 4 5]
```


# defer
## 基本语法
关键字 defer 允许`延迟执行某个语句或函数`到函数执行完毕返回之前（函数体最后 或 return 之后），一般用于释放某些已分配的资源。
```go
package main

import "fmt"

func main() {
    a := 1
    b := 2
    defer fmt.Println(b)
    fmt.Println(a)
}
// 1
// 2
```
当有多个 defer 行为被注册时，它们会以`逆序执行`（类似栈，即`后进先出`）：
```go
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
// 4 3 2 1 0 
```

思考：
```go
func f() (ret int) {
	defer func() {
		ret++
	}()
	return 1
}
func main() {
	fmt.Println(f())
}
// 2
```

## 应用
一般进行一些函数执行完成后的收尾工作：
- 关闭文件流
    ```go
    file.Open("file")
    defer file.Close()
    ```
- 解锁一个加锁的资源
    ```go
    mu.Lock()  
    defer mu.Unlock() 
    ```
- 打印最终报告
- 关闭数据库链接

1. 实现代码追踪，在进入和离开某个函数打印相关的消息
2. 调试时，记录函数的参数与返回值


# 内置函数
- `close` 用于管道通信
- `len、cap`
    + len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；
    + cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
- `new、make`：均是用于分配内存：
    + new 用于值类型和用户定义的类型，如自定义结构，new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。
    + make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作，new() 是一个函数，不要忘记它的括号
- `copy、append`：用于复制和连接切片
- `panic、recover`：两者均用于错误处理机制
- `print、println`：底层打印函数，在部署环境中建议使用 fmt 包
- `complex、real imag`：用于创建和操作复数

# 可变参数函数
## 基本语法
Go 中的函数，支持变参，就是可以传递任意数量的参数。如果一个函数的最后一个参数形如：...Type，则该参数（形参）可以接受不同数目的参数（实参）。
> func f(elems ...Type)

内置函数 append() 就是一个可变参数函数。
> func append(slice []Type, elems ...Type) []Type

注意：
- 主要是使用...来处理函数的参数序列，在形参中是`收缩`，在实参中是`展开`的作用。
- 只允许最后一个参数是可变参数

## 原理
```go
func main() {
	x := min(1, 3, 2, 0)
	fmt.Printf("The minimum is: %d\n", x)
}

func min(s ...int) int {
	fmt.Printf("%T\n", s) // %T 输出变量类型
	fmt.Println(s)
	if len(s) == 0 {
		return 0
	}
	min := s[0]
	for _, v := range s {
		if v < min {
			min = v
		}
	}

	return min
}
// []int
// [1 3 2 0]
// The minimum is: 0
```
可以看到，在 min 函数中打印 s 的类型输出是 []int 类型，参数 s 是一个切片。可见，可变参数函数的工作原理就是`把参数序列收缩为一个切片`。

如果调用 min 函数时，可以不传递参数，这种情况下，s 是一个长度和容量都是 0 的 nil 切片。


## 给可变函数直接传入一个切片
Go 提供了将切片直接传入可变参数函数的`语法糖`：使用 ... 将 slice 展开为参数序列。这样，切片将直接传入函数，`不会再创建新的切片`。
```go
func main() {
	slice := []int{7, 9, 3, 5, 1}
	x = min(slice...)
	fmt.Printf("The minimum in the slice is: %d", x)
}
```

如果，在函数内部将切片修改了呢？会发生什么呢？
```go
func main() {
	slice := []int{3, 5, 1}
	change(slice...)
	fmt.Println("slice=", slice)
}

func change(s ...int) {
	s[0] = 10
	fmt.Println("s=", s)
}
// s= [10 3 5]
// slice= [10 3 5]
```
可以看到，虽然在 change 函数内部修改了切片，但函数外面的 slice 也改变了。


这点是区别于 JS 的：
```js
const change = (...params) => {
	console.log("type=", Object.prototype.toString.call(params)); // type= [object Array]
	console.log("params=", params);
	params[0] = 10;
};

let ary = [1, 3, 5];
change(...ary);
console.log("ary=", ary);
// params= [1, 3, 5]
// ary= [1, 3, 5]
```
函数外面的 ary 并没有被修改。


<!-- 2. 当参数的类型不同时
- 使用结构体
- 使用 空接口 interface{}
一般而言我们会使用一个 for-range 循环以及 switch 结构对每个参数的类型进行判断 -->


