- 布尔型 bool
- 数值型
- 字符串型 string


# bool
> a && b // 同 JS
>
> a || b // 同 JS


# numeric types
- int8, int16, int32, int64, int
- uint8, uint16, uint32, uint64, uintptr
- float32, float64
- complex64, complex128：复数，比如 3 + 4i(实部 + 虚部)
- byte： 8位
- rune： 32位，字符型  char类型

u: 有符号整数
规定长度的

byte 是 uint8 的别名。

## rune
rune 是 Go 的内置数据类型，是 int32 的别名，表示 Go 中的 Unicode 代码点。


# string
字符串本质上是一个字节数组，是一个值类型。
- len 获取的是字节长度
- []byte 获得字节
- utf8.RuneCountInString 获得的是字符数量


interpreted string literals("...") 和 raw string literals (`...`) 
原生的字符串面值形式是`...`

1. 内置的len函数
```go
s := "Yeah"
fmt.Println(len(s))
fmt.Println(s[0], s[1])
fmt.Printf("%T ", s[0])
// 4
// 89 101
// uint8
```
`s[i]`：返回`字节值，不是字符`，是每个字母在 ASCII 码表上对应的十进制数字。
值的类型都是 uint8 即 byte 类型，byte 是 uint8 的别名。

练习："HelloWorld"，每三个字符插入一个逗号
```go
func comma(s string) string {
    n := len(s)
    if n <= 3 {
        return s
    }
    return comma(s[:n-3]) + "," + s[n-3:]
}
```


2. + 连接


3. 截取
`s[i:j]`：截取第 i 到 第 j个（不包含 j）字符
不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。
```go
fmt.Println(s[0:3]) // hel
fmt.Println(s[:3])  // hel
fmt.Println(s[1:])  // ello
```

4. 字符串的值是不可变的
```go
s := "left foot"
t := s
s += ", right foot"
fmt.Println(s) // "left foot, right foot"
fmt.Println(t) // "left foot"
```
因为字符串是不可修改的
```go
s[0] = 'L' // compile error: cannot assign to s[0]
```

## 常见字符串包
四个处理字符串的包：bytes、strings、strconv、unicode。

strings包中常用的API
- 包含：
    + Contains(s,substr)
    + ContainsAny(s,substr)
- 前缀和后缀
    + HasPrefix(s, substr) // 是否是以指定的内容开头
    + HasSuffix(s, substr) // 是否是以指定的内容结束
- 去空格
    + Trim
    + TrimRight
    + trimLeft
- 搜索：
    + Index(s,substr) // 返回第一次出现的索引位置，如果不存在，返回-1。
    + LastIndex(s,substr) // 返回最后一次出现的位置
- 替换：
    + Replace(s,old,new,n),n表示替换的次数，如果全部替换，-1
- 统计：
    + Count(s,substr)
- 大小写转换：
    + ToLower()
    + ToUpper()
- 切割：
    + Split()
    + Join()
- 重复：
    + Repeat(s,n)
- 截取：
    + s[start:end]--> 截取子串

```go
func HasPrefix(s, prefix string) bool {
    return len(s) >= len(prefix) && s[:len(prefix)] == prefix
}
func HasSuffix(s, suffix string) bool {
    return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}
func Contains(s, substr string) bool {
    for i := 0; i < len(s); i++ {
        if HasPrefix(s[i:], substr) {
            return true
        }
    }
    return false
}
```

6. `字符串和Byte切片`
字符串是不可变的。一个字节slice的元素则可以自由地修改。

字符串和字节slice之间可以相互转换：
```go
s := "abc"
b := []byte(s)
s2 := string(b)
fmt.Println(s2, b)
// abc [97 98 99]
```
=> 修改字符串中的某个字符

一个[]byte(s)转换是分配了一个新的`字节数组`用于保存字符串数据的拷贝，然后引用这个底层的字节数组。


7. 字符串和数字的转换
整数转为字符串: fmt.Sprintf 或 strconv.Itoa
```go
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y)
fmt.Println(strconv.Itoa(x))
// "123"
// "123"
```
字符串解析为整数: strconv.Atoi 或 strconv.ParseInt
```go
x, err := strconv.Atoi("123")             // x is an int
y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
fmt.Println(x, y, err)
// "123 123 <nil>"
```


# ASCII 、UTF-8 和 Unicode
```go
// UTF - 8 编码
// 英文 1字节，中文 3字节
s := "Yeah秋!"
fmt.Println(len(s)) // 8 = 4 + 3 * 1 + 1
// fmt.Printf("%X ", []byte(s))

fmt.Println()
for i := 0; i < len(s); i++ {
    fmt.Printf("%x ", s[i])
}
// 59 65 61 68 e7 a7 8b 21
    
fmt.Println()
for _, b := range []byte(s) {
    fmt.Printf("%X ", b)
}
// 59 65 61 68 E7 A7 8B 21  

// Unicode 编码
fmt.Println()
for i, ch := range s { // ch is a rune，4字节的整数
    fmt.Printf("(%d %X ) ", i, ch)
}
// (0 59 ) (1 65 ) (2 61 ) (3 68 ) (4 79CB ) (7 21 ) 

// utf8 库
fmt.Println()
fmt.Println(utf8.RuneCountInString(s)) //6


// rune
fmt.Println()
for i, ch := range []rune(s) {
    fmt.Printf("(%d %c) ", i, ch)
}
// (0 Y) (1 e) (2 a) (3 h) (4 秋) (5 !) 
```
%v: 十进制值；%x 以十六进制输出；%T 格式化输出值的类型。
比如: 
Y，UTF8 编码：59，对应的 Unicode 编码：59
秋，UTF-8 编码：E7 A7 8B，对应的 Unicode 编码：79CB

熟悉 ASCII 、UTF-8 和 Unicode，可以看一下阮一峰老师的[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
