
在别的语言（例如 JS）中，函数即方法，方法即函数。在 Go 中，是严格区分这两者的概念的。

# 为什么需要方法
Go 不是纯粹的面向对象的语言且不支持类，通过类型的方法可以实现和类相似的功能，又不会像类那样显得很“重”；

# 定义
Go 中的方法区别于函数的地方在于：方法是一个包含了接收者（receiver）的函数，接收者可以是命名类型或者结构体类型的一个值或者指针。所有给定类型的方法的集合属于该类型的方法集。

定义格式：
```go
func (receiver receiver_type) function_name( [parameter list] ) [return_types]{
   body
}
```
- receiver：接收者
- receiver_type： 接收者的类型


# receiver
- 如果 receiver 是 receiver_type 的实例，就相当于我们 JS 中的 this、self，实例按值调用方法，通过 object.name 来访问。这样的方法我们称为`值方法`。在方法内部，一般都是访问输出。
- 如果 receiver 是一个指向 receiver_type 的指针，这样的方法，我们称为`指针方法`。在方法内部，可以修改外面指针对应的值。

Go 会自动解引用，自动探测 receiver 是指针，还是值。


> `指针或非指针上都可以调用指针方法和值方法`。

当一个值调用指针方法时，会自动转换为指针，当一个指针调用值方法时，会自动从指针处取值。
比如 一个类型 T 的变量 t，调用指针方法 change() 时，t.change() 会自动转换为 (&t).change()。
```go
type List []int

func (l List) Len() int {
	return len(l)
}
func (l *List) Append(val int) {
	*l = append(*l, val)
}

func main() {
	// 值
	var lst List
	lst.Append(1)
	fmt.Printf("%v (len: %d)\n", lst, lst.Len())
	// [1] (len: 1)

	// 指针
	plst := new(List)
	plst.Append(2)
	fmt.Printf("%v (len: %d)", plst, plst.Len())
	// &[2] (len: 1)
}
```
每个方法声明的时候，编译器会各自声明相对应的隐式函数。
```go
func List.Len(l List) int {
	return len(l)
}
func List.Append(l *List, val int) {
	*l = append(*l, val)
}
```

方法的接收者是副本：值方法的接收者是原类型值的副本，指针方法的接收者是原类型值的指针副本。在值方法内对副本修改不会影响到原值，例外：除非这个类型是引用类型的别名类型。而在指针方法内，对指针副本指向的值做的修改一定会体现在原值上。
```go
type Book struct {
	pages int
}

type Books []Book

func (books Books)modify()  {
	// 原值已被修改
	books[0].pages = 188
	// 下面这行代码不会修改原值
	books = append(books,Book{234})
}

func main() {
	books := Books{
		{123},
		{456},
	}
	books.modify()
	fmt.Println(books)    // 输出：[{188} {456}]
}
```
`append() 调用不会影响到原值`，是因为该操作会`重新申请一块内存`存放接收者 books，但不会影响到原值。




# receiver_type
receiver 的类型（几乎）可以是任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。
- 接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：invalid receiver type…。
- 接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。

结构体类型的方法：
```go
type Employee struct {
	name     string
	salary   int
	currency string
}

func (e Employee) displaySalary() {
	fmt.Printf("Salary of %s is %s%d", e.name, e.currency, e.salary)
}

func main() {
	emp1 := Employee{
		name:     "Chen",
		salary:   5000,
		currency: "$",
	}
	emp1.displaySalary()
}
// "Salary of Chen is $5000"
```

非结构体类型的方法：
```go
type IntVector []int

func (v IntVector) Sum() (s int) {
	for _, x := range v {
		s += x
	}
	return
}

func main() {
	fmt.Println(IntVector{1, 2, 3}.Sum())
}
// "6"
```
