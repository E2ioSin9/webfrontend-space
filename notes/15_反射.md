Go的反射机制是程序检查其自身结构，属于元编程的范畴。可以在运行时检查类型和变量。

# reflect包
一般使用 reflect 包：两个简单的函数，reflect.TypeOf 和 reflect.ValueOf，返回被检查对象的类型和值。

任意一个变量 x，
- t = reflect.TypeOf(x)
- v = reflect.TypeOf(x)
    + v.Type()：
    + v.Kind()：返回底层类型
    + v.Interface()：转换成 interface{} 类型


反射基本类型 float64：
```go
var x float64 = 3.4
fmt.Println("type:", reflect.TypeOf(x)) // float64

v := reflect.ValueOf(x)
fmt.Println("value:", v) // 3.4
fmt.Println("type:", v.Type()) // float64
fmt.Println("kind:", v.Kind()) // float64
fmt.Println("value:", v.Float()) // 3.4
fmt.Println(v.Interface()) // 3.4

y := v.Interface().(float64)
fmt.Println(y) // 3.4
```


# 反射结构体
- t = reflect.TypeOf(x)
    + t.Name()：获取通过 struct 定义的新类型的名称
    + t.NumField()： 获取结构体的字段数量
    + t.Field()： 获取结构体的字段
    + t.NumMethod()：获取结构体的方法数量
    + t.Method()：获取结构体的方法签名
- v = reflect.TypeOf(x)
    + v.Field()：获取结构体类型的数据

```go
type User struct {
    Id int
    Name string
    Age int
}

func (u User) Hello() {
    fmt.Println("Hello world!")
}

func main() {
    u := User{1, "Chen", 12}
    Info(u)
}
func Info(o interface{}) {
    t := reflect.TypeOf(o)
    fmt.Println("Type:", t.Name())
    // t.Kind() 获取底层的类型，检测是否是 reflect.Struct 类型
    if k := t.Kind();k != reflect.Struct {
        fmt.Println("xx")
        return
    }

    v := reflect.ValueOf(o)
    fmt.Println("Fields:") 

    for i := 0; i < t.NumField(); i++ {
        f := t.Field(i)
        val := v.Field(i).Interface()
        fmt.Println(f.Name, f.Type, val)
    }
    for i := 0; i < t.NumMethod(); i++ {
        m := t.Method(i)
        fmt.Println(m.Name, m.Type)
    }
}
// Type: User
// Fields:
// Id int 1
// Name string Chen
// Age int 12
// Hello func(main.User)
```

反射匿名、嵌入字段：
```go
type User struct {
    Id int
    Name string
    Age int
}

type Manager struct {
    User
    Title string
}

func main() {
   type User struct {
	Id   int
	Name string
	Age  int
}

type Manager struct {
	User
	title string
}

func main() {
	m := Manager{User: User{1, "Chen", 12}, title: "title-1"}
	t := reflect.TypeOf(m)
    fmt.Printf("%#v\n", t.Field(0))
    // reflect.StructField{Name:"User", PkgPath:"", Type:(*reflect.rtype)(0x108dc0), Tag:"", Offset:0x0, Index:[]int{0}, Anonymous:true}
    fmt.Printf("%#v\n", t.Field(1))
    // reflect.StructField{Name:"title", PkgPath:"main", Type:(*reflect.rtype)(0x101680), Tag:"", Offset:0x10, Index:[]int{1}, Anonymous:false}

}

```


# 通过反射修改（设置）值
- v.CanSet()：检测 v 是否可修改（设置）
- v.Elem()：

1. 修改基本类型
```go
func main() {
	var x float64 = 3.4
	v := reflect.ValueOf(x)
	// setting a value:
	// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value
	fmt.Println("settability of v:", v.CanSet())
    
    v = reflect.ValueOf(&x) // Note: take the address of x.
	fmt.Println("type of v:", v.Type())
	fmt.Println("settability of v:", v.CanSet())
    
    v = v.Elem()
	fmt.Println("The Elem of v is: ", v)
	fmt.Println("settability of v:", v.CanSet())
	v.SetFloat(3.1415) // this works!
	fmt.Println(v.Interface())
	fmt.Println(v)
}
// settability of v: false

// type of v: *float64
// settability of v: false

// The Elem of v is:  <float64 Value>
// settability of v: true
// 3.1415
// <float64 Value>
```

```go
x := 12
v := reflect.ValueOf(&x)
v.Elem().SetInt(999)

fmt.Println(x)
```

2. 修改结构

```go
type User struct {
    Id int
    Name string
    Age int
}

func main() {
	u := User{1, "Chen", 12}
	Set(&u)

	fmt.Println(u)
}

func Set(o interface{}) {
	v := reflect.ValueOf(o)
	// 判断 v是不是一个 pointer interface，是不是可修改值
	if v.Kind() == reflect.Ptr && !v.Elem().CanSet() {
		fmt.Println("xx")
		return
	}
    v = v.Elem()

    // 1. 检测是否真的找到了某个字段
    // f := v.FieldByName("Name")
    // if !f.IsValid() {
    //     fmt.Println("bad")
    //     return
    // }

    // 2. 修改 User 的 Name
    // v.FieldByName([field_name]) 找到结构体的某个字段
	if f := v.FieldByName("Name"); f.Kind() == reflect.String {
		f.SetString("Yang")
	}
}
// {1 Yang 12}
```

# 通过反射进行方法的调用
```go
type User struct {
	Id   int
	Name string
	Age  int
}

func (u User) Hello(name string) {
	fmt.Println("Hi", name, ",my name is:", u.Name)
}

func main() {
	u := User{1, "Chen", 12}
	v := reflect.ValueOf(u)
	m := v.MethodByName("Hello")
    // ?????
	args := []reflect.Value{reflect.ValueOf("Joe")}
	m.Call(args)
}
```