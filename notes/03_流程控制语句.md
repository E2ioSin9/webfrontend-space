Go 提供了下面这些条件结构和分支结构：
- if-else 结构
- switch 结构
- select 结构，用于 channel 的选择
可以使用迭代或循环结构来重复执行一次或多次某段代码（任务）：
- for (range) 结构
一些如 break 和 continue 这样的关键字可以用于中途改变循环的状态。

此外，你还可以使用 return 来结束某个函数的执行，或使用 goto 和标签来调整程序的执行位置。


# if-else
## 语法
1. 一般语法：
    ```go
    // if
    if condition {
        // do something	
    }

    // if-else 
    if condition {
        // do something	
    } else {
        // do something	
    }
    ```
2. 当 if 结构内有 break、continue、goto 或者 return 语句时，Go 代码的常见写法是省略 else 部分：
    ```go
    if condition {
        return A
    }
    return B
    ```
    例子：
    ```go
    func Abs(x int) int {
        if x < 0 {
            return -x
        }
        return x	
    }
    ```

3. if 可以包含一个初始化语句:
    ```go
    if initialization; condition {
        // do something
    }
    ```
    使用简短方式 := 声明的变量的作用域只存在于 if 结构中。

    例子：
    ```go
    x := 10
    if x > max {
        // do something
    }
    // 等同于
    if x := 10; x > max {
        // do something
    }
    ```


## 处理错误
Go 语言的函数经常使用两个返回值来表示执行是否成功：返回某个值以及 true 表示成功；返回零值（或 nil）和 false 表示失败。

处理错误：当不使用 true 或 false 的时候，也可以使用一个 error 类型的变量来代替作为第二个返回值：成功执行的话，error 的值为 nil，否则就会包含相应的错误信息。

常见用法：
```go
identifier, err := functionName(params)
if err != nil {
	// print the error
	return err
}
// 未发生错误，继续执行
// do something
```
可以将 err 的初始化放在 if 结构中。
```go
if identifier, err := functionName(params); err != nil {
	// print the error
	return err
}
```



# switch
每一个 case 分支都是唯一的，从上至下逐一匹配，一旦匹配就不会往下执行别的 case。

区别于JS：
- 没有break，不需要使用 break 来跳出当前分支
- fallthrough 关键字：如果希望继续执行紧跟的下一个case。，就使用 fallthrough 关键字。
- 可以不写 default

```go
i := 0

switch i {
case 0:
    fmt.Println("===0")
    fallthrough
    // fmt.Println("test") // fallthrough statement out of place
case 1:
    fmt.Println("===1")
case 2:
    fmt.Println("===2")
default:
    fmt.Println("default")
}
// "===0"
// "===1"
```

还可以不写 switch 后面，被判断的表达式：
- 默认为 true，直接按顺序执行下边的 case
- 当 case 分支中的条件为 true 时，执行后边的代码
```go
i := 0

switch {
case i < 0:
    fmt.Println("< 0")
case i == 0:
    fmt.Println("===0")
case i > 0:
    fmt.Println("default")
}
// "===0"
```




# for
Go 只有一种循环结构：for 循环。

## 基本语法
> for 初始化语句; 条件语句; 修饰语句 {}

基本的 for 循环由三部分组成，它们用分号隔开：
- 初始化语句(可选的)：通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。
- 条件表达式(必须有)
- 后置语句(可选的)


```go
a := [3]int{1, 2, 3}
for i := 0; i < len(a); i++ {
    fmt.Println(a[i])
}
// 1
// 2
// 3
```


```go
sum := 0
for i := 0; i < 5; i++ {
    sum += i
}
fmt.Println(sum)
// 10
```

```go
sum := 1
for ; sum < 3; {
    sum += sum
}
fmt.Println(sum)
// 4
```

## 只写条件语句
for 只写条件语句，去掉分号，就是 `Go 中的 “while”`：
> for 条件语句 {}

```go
sum := 1
for sum < 3 {
    sum += sum
}
fmt.Println(sum)
// 4
```

等同于JS：
```js
let sum = 1;
while(sum < 3) { 
    // ...
}
```

## 无限循环
for 去掉循环条件，就是无限循环
```go
for {
    // ...
}
```
等同于JS：
```js
while(true) {
    // ... 
}
```



# for-range 结构
主要应用于 slice、map、数组、字符串，等同于 JS 的 for-of、for-in。

```go
for index, value := range arr/slice {
	...
}
```
- index：数组或者切片的索引，忽略用_
- value：索引对应的值，忽略直接不写
```go
var arr [3]int

// Print the indices and elements.
for i, v := range arr {
    fmt.Printf("%d %d\n", i, v) // %d 十进制
}
// 0 0
// 1 0
// 2 0

// Print the elements only.
for _, v := range arr {
    fmt.Printf("%d\n", v)
}
```
等同于JS：
```js
let arr = [ 0, 0, 0 ];

for (let v of arr) {
    console.log(v);
}
```


需要注意的是：
value 只是对某个位置的对应值的一个拷贝，修改 value 的操作并不会修改原始数组或切片。

```go
items := [...]int{10, 20, 30, 40, 50}
for _, value := range items {
	value *= 2
}
fmt.Println(items)
// [10, 20, 30, 40, 50]
```

使用 for 循环就可以修改值。
```go
items := [...]int{10, 20, 30, 40, 50}
for i:= 0; i < len(items); i++ {
    items[i] *= 2
}
fmt.Println(items)
// [20 40 60 80 100]
```