面向接口编程：继承和多态，通过接口实现。
Go 语言是编译时绑定，而不是动态绑定。

接口定义了一组方法的集合。
特点：
- 接口`只有方法声明，没有实现`，也不能包含变量。
- 可以匿名嵌入其它接口或结构中

# 接口定义
```go
type Namer interface {
    Method1(param_list) return_type
    ...
}
```
接口是由**使用者**来定义的。

# 隐式实现
当一个类型 T 提供了接口中所有方法的定义（实现）时，就说 T 实现了接口。接口指定类型应该有哪些方法，类型决定如何去实现这些方法。

```go
/* 定义接口 */
type Namer interface {
    Method1(param_list) return_type
    ...
}

/* 定义结构体 */
type T struct {
   /* variables */
}

/* 实现接口方法 */
// 类型不需要显式声明它实现了某个接口。此方法表示类型 T 隐式实现了接口 Namer
func (T_variable T) Method1() [return_type] {
   /* 方法实现 */
}
```


# 接口值
## 静态类型和动态类型
接口也是值，也可以被传递。
接口值可以看做包含`实现者的值和具体类型的元组：(value, type)`。接口值调用方法时，会执行其底层类型的同名方法。

```go
type I interface {
	M()
}

type T struct {
	S string
}

func (t *T) M() {
	fmt.Println(t.S)
}

type F int

func (f F) M() {
	fmt.Println(f)
}

func main() {
	var i I

	i = &T{"Hello"}
	describe(i) // &{Hello}, *main.T
	i.M() // Hello

	i = F(5)
	describe(i) // 5, main.F
	i.M() // 5
}

func describe(i I) {
	fmt.Printf("%v, %T\n", i, i)
}
```

> 接口类型
>- 静态类型：在声明时指定的不能改变的类型，就是接口本身。
>- 动态类型：实现接口的值的类型，`包名.类型`

上边的例子，变量 i 的静态类型是 I，是不能改变的。动态类型却是不固定的，第一次分配之后，i 的动态类型是 *main.T，动态值都是&{Hello}。第二次分配之后，i 的动态类型是 main.F，动态值都是 5。


## nil 接口值
当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。
```go
var a interface{}
fmt.Println(a == nil) // true

var p *int = nil
a = p
fmt.Printf("%v, %T\n", a, a) // <nil>, *int
fmt.Println(a == nil) // false
```


# 实现接口
多个类型可以实现同一个接口。上边的例子，类型 T 和 F 都实现了同一个接口 I。
一个类型可以实现多个接口。

```go
type Shape interface {
	Area() float32
}

type Object interface {
	Perimeter() float32
}

type Circle struct {
	radius float32
}

func (c Circle) Area() float32 {
	return math.Pi * (c.radius * c.radius)
}

func (c Circle) Perimeter() float32 {
	return 2 * math.Pi * c.radius
}

func main() {
	c := Circle{3}
	var s Shape = c
	var p Object = c
	fmt.Println("area: ", s.Area())
	fmt.Println("perimeter: ", p.Perimeter())
}
```
类型 Circle 实现了接口 Shape 和 Object。因为 s 的静态类型是 Shape，如果 s.Perimeter()，编译报错，s.Perimeter undefined (type Shape has no field or method Perimeter)



# 类型断言(Type assertion)
一个接口类型的变量 i 中可以包含任何类型的值，必须有一种方式来检测它的 `动态类型`，即`运行时在变量中存储的值的实际类型`：

常见形式：
```go
v, ok := i.(Type)
```
类型断言 i.(Type) 可返回两个值：其底层值以及一个报告断言是否成功的布尔值。
如果转换合法，v 是 接口 i 转换到类型 Type 的值，ok 会是 true；否则 v 是类型 Type 的零值，ok 是 false。
```go
var i interface{} = "hello"

s := i.(string)
fmt.Println(s)

s, ok := i.(string)
fmt.Println(s, ok)

f, ok := i.(int)
fmt.Println(f, ok)
// hello
// hello true
// 0 false
```


# 类型选择
type-switch: case 为类型（而非值）
```go
switch v := i.(Type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 varI 的类型相同
}
```



# 空接口
一个不包含任何方法的接口，称之为空接口，形如：interface{}。
Go 语言中的任何类型都实现了空接口。空接口不包含任何方法，类似 JS 中所有类的基类：Object 类。
> type Any interface{}

可以给一个空接口类型的变量赋任何类型的值。

每个 interface{} 变量在内存中占据两个字长：一个用来存储它包含的`类型`，另一个用来存储它包含的`数据`或者`指向数据的指针`。
```go
var i = 5
var str = "ABC"

type Person struct {
	name string
	age  int
}

type Any interface{}

func main() {
    var val Any
    // int
	val = 5
    fmt.Println(val) // 5
    
    // string
	val = str
    fmt.Println(val) // ABC
    
    // Person
	pers1 := new(Person)
	pers1.name = "Rob Pike"
	pers1.age = 55
	val = pers1
    fmt.Println(val) // &{Rob Pike 55}
    
    // type-switch
	switch t := val.(type) {
	case int:
		fmt.Printf("Type int %T\n", t)
	case string:
		fmt.Printf("Type string %T\n", t)
	case bool:
		fmt.Printf("Type boolean %T\n", t)
	case *Person:
		fmt.Printf("Type pointer to Person %T\n", t)
	default:
		fmt.Printf("Unexpected type %T", t)
	}
}
// Type pointer to Person *main.Person
```

应用：函数的参数类型可以定义为 interface{}，那就可以传入任何类型，提升函数的通用性。

举个例子，fmt 包中的 Println() 函数，可以接收多种类型的值，比如：int、string、array等。为什么，因为它的形参就是接口类型，可以接收任意类型任意数量的值。
> func Println(a ...interface{}) (n int, err error) {}



# 方法集
每个类型都有与之关联的方法集。
- 类型 T 方法集仅包含所有值方法。
- 类型 *T 方法集包含所有值方法和指针方法。
```go
type List []int

func (l List) Len() int {
	return len(l)
}

func (l *List) Append(val int) {
	*l = append(*l, val)
}
```
自定义类型 List 的方法集合只包括值方法，即 Len()，而 *List 类型的方法集合包含这两个方法。


```go
type Appender interface {
	Append(int)
}

type List []int

func (l *List) Append(val int) {
	*l = append(*l, val)
}

func main() {
	// A bare value
	var lst List
	CountInto(&lst, 1, 5) // 传入 lst 报错:
	fmt.Println(lst)
}

func CountInto(a Appender, start, end int) {
	for i := start; i <= end; i++ {
		a.Append(i)
	}
}
// [1 2 3 4 5]
```
上边代码，定义了一个接口 Appender，只包含一个方法 Append()，实现了该方法就实现了该接口。因此，*List 类型实现了接口 Appender。
- List 类型的方法集包含值方法，为空。
- *List 类型的方法集包含值方法和指针方法，即包含 Append() 方法。 

CountInto(lst, 1, 5) 报错，是因为 List 类型的方法集不包含 Append()，也就没有实现接口 Appender。

我们再来看进阶一点的例子：
```go
type Speaker interface {
	Speak()
}

type User struct {
	Name  string
	Email string
}

type Admin struct {
	User
	Level string
}

func (u *User) Speak() {
	fmt.Println("I am user", u.Name)
}

func main() {
	admin := Admin{
		User: User{
			Name:  "Jack",
			Email: "Jack@gmail.com",
		},
		Level: "admin",
	}
	gotoSpeak(&admin)
}

func gotoSpeak(s Speaker) {
	s.Speak()
}
// I am user Jack
```

假设外部结构体类型是 O，内部类型是 I，则关于内部类型的方法提升如下规则：

I 嵌入 O，外部类型 O 可以通过值类型或指针类型调用内部类型 I 的值方法；
I 嵌入 O，外部类型 O 只能通过指针类型调用内部类型 I 的指针方法；
*I 嵌入 O，外部类型 O 可以通过值类型和指针类型调用内部类型 I 的值方法和指针方法；

上面的三条规则可以总结成一句话：不管是 I 嵌入 O，还是 *I 嵌入 O，`外部类型 O 唯独通过值类型不能调用内部类型 I 的指针方法外`，其他情况下内部类型 T 的方法都可以获得提升，即可被外部类型 O 访问。
`指针接收者实现只能以指针方式使用，值接受者都可以`。
```go
type Admin struct {
	*User            // 通过指针方式组合
	Level string
}

func main() {
	admin := Admin{
		User: &User{
			Name:  "Jack",
			Email: "Jack@gmail.com",
		},
		Level: "admin",
	}
	gotoSpeak(&admin)
	gotoSpeak(admin)
}
// I am user Jack
// I am user Jack
```

# 常用内置接口
Stringer
Reader/Writer
