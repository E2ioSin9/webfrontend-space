Go 没有像 Java 那样的 try/catch 异常机制：不能执行抛异常操作，但是有一套 defer-panic-and-recover 机制。


Go 是怎么处理普通错误的呢？
通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值——如果返回 nil，则没有错误发生——并且主调（calling）函数总是应该检查收到的错误。

# 定义错误
Go 语言通过内置的错误接口提供了非常简单的错误处理机制。

error 类型是一个接口类型，我们看它的定义：
```go
type error interface {
    Error() string
}
```

函数通常在最后的返回值中返回错误信息。使用 errors.New 可返回一个错误信息。
```go
func main() {
	if f, err := Sqrt(-1); err != nil {
		fmt.Println(err, f)
	}
}

func Sqrt(f float64) (float64, error) {
	if f < 0 {
		return 0, errors.New ("math - square root of negative number")
	}
	return f, nil
}
// math - square root of negative number 0
```


# defer-panic-and-recover
1. panic 
    Go 运行时负责中止程序并给出调试信息。
    - 产生一个中止程序的运行时错误
    - 接收一个做任意类型的参数，通常是字符串
在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 panicking。

2. recover
    - 主要用于从 panic 或 错误场景中恢复：停止终止过程而恢复正常执行
    - recover 只能在 defer 修饰的函数中使用
        + 如果是恢复执行，取得 panic 调用中传递过来的错误值
        + 如果是正常执行，调用 recover 会返回 nil，且没有其它效果

```go
package main

import (
	"fmt"
)

func badCall() {
	panic("bad end")
}

func test() {
	defer func() {
		if e := recover(); e != nil {
			fmt.Println("Panicing:", e)
		}
	}()
	badCall()
	fmt.Printf("After bad call\r\n") // <-- wordt niet bereikt  为什么不执行???
}

func main() {
	fmt.Printf("Calling test\r\n")
	test()
	fmt.Printf("Test completed\r\n")
}
// Calling test
// Panicing: bad end
// Test completed
```


