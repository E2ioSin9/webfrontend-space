目录

[TOC]

生命周期函数：描述一个组件或程序从创建到销毁的过程，在这个过程中，某一时刻会调用的钩子函数

# v16.3 之前老的生命周期
[old-demo](https://codesandbox.io/s/react-old-lifecycles-0y05e)


洋葱模型：
- componentWillMount -> componentDidMount
- componentWillUpdate-> componentDidUpdate

  ![onion](https://user-images.githubusercontent.com/22387652/81921623-7a5edd00-960d-11ea-8d8e-7483f941fe14.png)


# v16.4 之后新的生命周期
![new](https://user-images.githubusercontent.com/22387652/79878598-30287880-8420-11ea-979e-91c0827db353.png)

## Mounting（挂载阶段）
挂载：当组件实例第一次被创建并插入 真实DOM 中，也就是，第一次被渲染到页面的过程。
- `constructor()`：初始化 state。

- `static getDerivedStateFromProps(props, state)`：第一次挂载之前

- `render()`：第一次挂载的过程
返回以下类型：React 元素、数组或 fragments 等

- `componentDidMount()`：第一次挂载之后
DOM 元素挂载完成，可以获取到。相当于 Vue   的 mounted。
  + 初始化 DOM 节点（比如 大小或位置）
  + 发送异步 AJAX 请求，获取数据

注意：
1. constructor() 和 componentDidMount() 在组件的生命周期`仅执行一次`
2. UNSAFE_componentWillMount()：第一次挂载之前
在这获取 DOM 元素是 undefined。相当于 Vue 的 beforeMount。


### static getDerivedStateFromProps(props, state)
在初始挂载及后续更新时都会被调用。它应`返回一个对象来更新 state`，如果返回 null 则不更新任何内容。

注意：
- 不管是 `props 或 state` 发生变化，在每次渲染前都会被触发。这与 UNSAFE_componentWillReceiveProps 形成对比（仅在 props 发生改变后触发，而不是内部调用 setState 时）
- static 表明是一个`静态方法`，而组件实例无法继承静态方法，所以该钩子函数内部`不能通过使用 this 获取组件实例的属性/方法`。=>通用的方式可以同样声明为一个 static function，在该钩子内部用 [类名].functionName 来调用

作用： 将父组件传递过来的 props 映射 到子组件的 state 上面，映射就相当于拷贝了一份父组件传过来的 props ，作为子组件自己的状态。注意：子组件通过 setState 更新自身状态时，不会改变父组件的 props

[online-demo](https://codesandbox.io/s/react-getderivedstatefromprops-mf95q)


## Updation（更新流程）

当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

- `static getDerivedStateFromProps(props, state)`：在每次渲染前触发。

- `shouldComponentUpdate(nextProps, nextState)`：当 props 或 state 发生变化时被调用。默认返回 true，返回 false，不执行执行后面的钩子函数，会“阻止”重新渲染。
  + this.state、this.props：页面渲染用的原来的值
  + nextProps、nextState：最新修改的，即将用它来渲染页面的值
  
    => 适合做一些拦截来优化性能，防止多次重新渲染。但一般用内置的 PureComponent。
    ==PureComponent 会对 props 和 state 进行浅层比较==

- `render()`：将新虚拟 DOM 与原来的进行比对（diff），然后修改真实DOM，重新渲染

- `getSnapshotBeforeUpdate(prevProps, prevState)`：render 之后、更新 DOM 和 refs 之前调用。应返回 snapshot 的值（或 null），作为 componentDidUpdate 的第三个参数。
=> 常用于在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）

  [online-demo](https://codesandbox.io/s/react-getsnapshotbeforeupdate-ij31n)

- `componentDidUpdate(prevProps, prevState, snapshot)`：重新渲染之后
  + this.state、this.props：最新修改的值
  + prevProps、prevState：页面渲染用的之前的值
  + snapshot：getSnapshotBeforeUpdate() 的返回值作为第三个参数

  => 通过比较 props，做一些操作：比如功能开关、发送请求。它必须被包裹在一个条件语句里，否则会导致死循环。


注意：
- 三种情况 props 会改变：
  + 父组件、或者 redux，通过 props 传递的数据发生改变
  + 路由切换引起的 props 上的 history/match/location 变化会触发
  
- 避免使用它们：UNSAFE_componentWillReceiveProps(nextProps, nextState)、UNSAFE_componentWillUpdate(nextProps, nextState)


## Unmounting（卸载流程）
当组件从 DOM 中移除之前会调用：

- `componentWillUnmount()`：一般用于重置数据、清除timer、取消订阅。

卸载并不是销毁组件，原有渲染的内容是不消失的，只不过以后不能基于数据改变视图了。


# 总结
由于 React 未来的版本中推出了异步渲染，在 dom 被挂载之前的阶段都可以被打断重来，导致 componentWillMount、componentWillUpdate、componentWillReceiveProps 在一次更新中可能会被触发多次，因此那些只希望触发一次的副作用应该放在 componentDidMount 中

这也就是为什么要把异步请求放在 componentDidMount 中，而不是放在 componentWillMount 中的原因，为了向后兼容。


# 面试高频题目
1. 说一下 React 组件的生命周期 *
哪几个你用的比较多，在什么情况下用这个





