目录

[TOC]

按照组件/模块管理的方式来构建程序，也就是把一个程序划分为一个个的组件来单独处理。

# 函数组件
1. 基础语法
- 接收一个唯一带有数据的 “props”（代表属性）对象（不传递是一个空对象）
  + children：`是一个不透明的数据结构`，可能是任何类型
    + 组件没有子元素（单闭合）时，是 undefined
    + 组件有子元素（双闭合）时，可能是一个值(字符串、对象)或一个数组
- 并返回一个 React 元素
- 本质上就是 JavaScript 函数
```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
ReactDOM.render(<div>
    <Welcome />
    <Welcome name='CHEN'>
        <span>1</span>
    </Welcome>
</div>, root);
```
注意：
- 在 JS 文件中，凡是用到 JSX 结构的，都要引入 React，因为需要基于它的 createElement 把 JSX 进行解析渲染。
- `React.Children 对象`，提供了 map、forEach 等方法专门处理 this.props.children。 [对React children 的深入理解](https://www.jianshu.com/p/d1975493b5ea)


# class 组件
1. 基础语法
使用 ES6 的 class 来定义组件：
- 必须有一个 render() 的方法，返回一个 JSX 元素
- super() 相当于 ==React.Component.call(this)==
  function Component(props, context, updater) { ... }
  
```js
class Welcome extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```
注意：
- `super()` 与 `super(props)`的区别：传入 props 是，将传递的属性挂载到子类的实例上，在 constructor 中可以使用 this.props；不传，this.props 拿到的是 undefined。super() 仅仅影响的是在 constructor 中获取 this.props；
- 执行完成 constructor，react 已经帮我们把传递的属性接收，并且挂载到实例上，其它生命周期函数中都可以使用 this.props


# 渲染机制
基于 createElement 把 JSX 转换为一个对象，当 render 渲染这个对象时，遇到一个组件，type 不再是字符串标签名，而是一个函数或者类，不再是直接创建元素，而是先把方法执行：

- 函数组件：就把它当做`普通方法执行`（严格模式下，方法中的this是`undefined`），把函数返回的 JSX 元素（也是解析后的对象）进行渲染。

- class 组件：把`当前类 new 执行`，创建类的一个实例（当前本次调取的组件就是它的一个实例），执行 constructor 之后，会执行 this.render()，把 render 中返回的 JSX 拿过来渲染。

```js
{
	type: Welcome,//=>组件Welcome
	props: {
		name: 'CHEN'
    children: 一个值或一个数组
  }
}
```

不管是哪种方式，函数执行时，都会把解析出来的`props属性对象作为实参传递给函数`。

# 应用
1. 函数组件
函数组件可以理解为`静态组件`。
[所谓静态组件，就是组件的内容是固定的，调取一次，就是将组件的内容插入到页面中，不需要与数据 model 进行交互。]

适用于：`只是简单的调取和返回 JSX 而已，不需要动态交互的情况`，例如，获取数据，绑定HTML

2. class 组件
class 组件可以理解为`动态组件`。
- 能够使用生命周期函数处理业务
- 可以基于组件内部的状态（state）来动态更新渲染组件的情况

适用于：`所有 需要和数据模型进行动态交互 的情况`。


# 组件之间通信
## 父子组件

父 通过 Props 传给 子，子 通过调用 父 传来的函数 修改父组件的数据，相当于向 父 传递。
特点：典型的单向数据流，只能父传子，不能子传父


## 兄弟组件（平行组件）
平行组件：兄弟组件或毫无关系的两个组件。

让两个兄弟组件有一个共同的父组件，一个兄弟组件把 父 传过来的函数执行，修改 父 中的数据，这样另一个 兄弟组件的数据也就改变了。


## 跨层级组件（传给所有后代）
Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树
```js
// 1. 使用 React.createContext(defaultValue)，创建一个 Context 对象。
const MyContext = React.createContext();

class App extends React.Component {
  render() {
    // 2. 使用 Provider 的 value 属性 来将当前的值 传递下去。
    // 无论多深，任何组件都能读取这个值。
    const user = {};

    return (
      <MyContext.Provider value={user}>
        <AppLayout />
      </MyContext.Provider>
    );
  }
}

// 中间的组件再也不必指明往下传递了。
function AppLayout() {
  return (
    <div>
      <Page />
    </div>
  );
}

class Page extends React.Component {
  // 使用：1. 指定 contextType 读取当前的 Context 对象
  // static contextType = MyContext;
  // render() {
  //   return <XXXComponent user={this.context} />;
  // }

  // // 使用：2. Context.Consumer
  // render () {
  //   return (
  //     <MyContext.Consumer>
  //       {value => /* 基于 context 值进行渲染*/}
  //     </MyContext.Consumer>
  //   );
  // }

  // 使用：3. useContext
  const user = useContext(MyContext);
  
  render() {
    return <XXXComponent user={user} />;
  }
}
```

特点：一旦父组件设置了上下文信息，它的后代组件都可以直接拿来用，不需要一层层传递。

## 任意组件
基于 redux 进行状态管理（常用），可以解决上述所有的通信情况。



# 面试高频题目
1. React 受控组件和非受控组件的区别
- 受控组件（Controlled）
又称为 stateless 组件。所有的组件依赖项都通过 props 传递到组件中，是一个 纯函数。使用 stateless 组件，能够在很大程度上提高组件本身的稳定性。
- 非受控组件（Uncontrolled）
又称为 stateful 组件。加入 state 之后，由于 state 是在组件内部的影响因素，外界难以控制 state 的变化，也无法得知 state 的变化，组件的不可控因素会增加，熵值增高。 

2. 组件之间通信方式
