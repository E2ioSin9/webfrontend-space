目录

[TOC]
# 基本语法
- 小驼峰式（camelCase），原生 camelcase
- 传入一个函数作为事件处理函数，而不是一个字符串
```js
<button onClick={this.onHandleClick}>
  {this.state.isToggleOn ? 'ON' : 'OFF'}
</button>
```


# bind this
==在 JS 中，class 的方法默认不会绑定 this==。如果不绑定 this，在 onHandleClick 中获取 this 是 undefined。==为什么？？？==
bind this 只是 修改方法的 this 指向。
```js
class EventDemo extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true };

    // 修改方法的 this 指向
    this.onHandleClick = this.onHandleClick.bind(this);
  }

  onHandleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.onHandleClick}>
        {this.state.isToggleOn ? "ON" : "OFF"}
      </button>
    );
  }
}
```
两种方式可以解决:
- 箭头函数
```js
onHandleClick = () => {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }));
  }
```
- 在 JSX 的回调中使用箭头函数
```js
<button onClick={() => this.onHandleClick()}>
  {this.state.isToggleOn ? "ON" : "OFF"}
</button>
```
- 另一种 bind 方法
```js
<button onClick={this.onHandleClick.bind(this)}>
  {this.state.isToggleOn ? "ON" : "OFF"}
</button>
```

# 向事件处理程序传递参数
1. 使用 bind(this, a, b)
2. JSX 的回调使用箭头函数传
```js
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button> // 不推荐
```
注意：最后追加一个参数，即可接受 event

# event
## 栗子
阻止 a 标签默认打开链接的行为：

1. 原生 Html 是这样的：通过返回 false 的方式
```js
<a href="#" onclick="console.log('The link was clicked.'); return false">
  Click me
</a>
```

2. React 中: 显式的调用 preventDefault()
```js
function ActionLink() {
  const onHandleClick = (event) => {
    event.preventDefault(); // 阻止 a 标签默认打开链接的行为
  }

  return (
    <a href="https://cn.bing.com/" onClick={onHandleClick}>
      Click me
    </a>
  );
}
```

## SyntheticEvent
>**event 并不是原生 event，是 React 封装的合成事件对象**：
>- 可以看到 \_\_proto__.constructor 输出的是 **SyntheticEvent**，它模拟出来 DOM 事件所有能力。
v- 通过 **event.nativeEvent** 可以获取原生事件对象，其  \_\_proto__.constructor 是 MouseEvent。
>- 所有的事件，都被挂载到 **document** 上

Vue 的 event 是原生的，事件被挂载到当前元素上。
```js
const onHandleClick3 = event => {
    console.log('event.target', event.target) // 指向当前元素，即当前元素触发
    console.log('event.currentTarget', event.currentTarget) // 指向当前元素，假象！！！

    
    console.log('event', event) // 不是原生的 Event ，原生的 MouseEvent
    console.log('event.__proto__.constructor', event.__proto__.constructor)

    // 原生 event 如下：
    console.log('event.nativeEvent', event.nativeEvent)
    console.log('event.nativeEvent.target', event.nativeEvent.target)  // 指向当前元素，即当前元素触发
    console.log('event.nativeEvent.currentTarget', event.nativeEvent.currentTarget) // 指向 document ！！！
  };
```

![event](https://user-images.githubusercontent.com/22387652/84558546-3541de00-ad66-11ea-8d1f-40545f1cbde0.png)


# 面试高频题目
1. 关于 event 参数